import{_ as e,r as t,o as p,c,b as s,d as n,e as o,a as i}from"./app-e8f85126.js";const l={},u=i(`<h2 id="开场" tabindex="-1"><a class="header-anchor" href="#开场" aria-hidden="true">#</a> 开场</h2><p>今天咱说说 Kotlin 的 implicit receiver。这是一个我们写 Kotlin 经常会用的东西，虽然你可能都没听过这个词，但你一定用过它。Kotlin 的很多高级功能，都利用到了这个概念——比如协程，协程是重度依赖它的，非常重。所以，弄明白它是个什么、怎么用、怎么去发挥它最大的价值，对我们的能力提升是非常有帮助的。</p><h2 id="定义-其实就是-this" tabindex="-1"><a class="header-anchor" href="#定义-其实就是-this" aria-hidden="true">#</a> 定义：其实就是 <code>this</code></h2><p>我们从它的定义说起。它的名字 implicit receiver，直接翻译到中文的话，叫隐式的接收器或者说接收者。啥叫「接收」啊？所谓的接收，其实指的就是接收调用，或者说接受调用。接受函数的调用啊，接受属性的访问啊。比如这个 <code>user.name</code>：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>user<span class="token punctuation">.</span>name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>左边的 <code>user</code> 就是它的 receiver。谁的 receiver？对于 <code>name</code> 的访问的 receiver。</p><p>而 implicit receiver，隐式的 receiver，指的就是不用写也自动存在的 receiver。也就是如果我把这个 <code>user.</code> 给删了，它依然能取到某个 <code>User</code> 对象的 <code>name</code>：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那么这个隐式地被应用的 <code>User</code> 对象，就是对这个 <code>name</code> 的访问的 implicit receiver，隐式的 receiver。</p><p>这就是 implicit receiver 的定义。</p><p>不过，咱把脑子转个弯想一下，这其实就是啥？就是 <code>this</code> 呗？对吧？</p><p>所谓的 implicit receiver，其实就是指的这个 <code>this</code>。</p><p>但 Java 里却没有隐式 receiver 这个概念，这是在 Kotlin 才增加了的概念。为啥呢？因为 Java 里的 <code>this</code> 很简单，就叫 <code>this</code> 就行了，不需要额外的专用名字；而 Kotlin 对它进行了一些关键的拓展，在拓展的同时，为了方便描述和沟通，就也给它起了专属的名字：implicit receiver。</p><p>那么它做了什么关键拓展呢？咱来从它的基本特性说起。</p><h2 id="嵌套的-implicit-receiver" tabindex="-1"><a class="header-anchor" href="#嵌套的-implicit-receiver" aria-hidden="true">#</a> 嵌套的 implicit receiver</h2><p><code>this</code>，或者说隐式的 receiver，是可以嵌套的，比如在 Java 里我们可以这么写：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OuterClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> outerInt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> innerInt <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>outerInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>innerInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我在这个内部类的里面，想访问内部类和外部类的成员都是可以的，是吧：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>outerInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>innerInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 <code>innerInt</code> 是 <code>InnerClass</code> 里的，所以它等价于加上 <code>this</code> 的写法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>outerInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>innerInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>而下面的 <code>outerInt</code> 属于外面的 <code>OuterClass</code>，但为了避免歧义，Java 不允许我们直接写 <code>this</code>：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesQXhRWT.png" alt=""></p><p>而需要显式地加上 <code>OuterClass</code> 的前缀：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">OuterClass</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>outerInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>innerInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>而上面的 <code>innerInt</code> 如果展开，前缀是 <code>InnerClass</code>：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> System.out.println(OuterClass.this.outerInt);
 System.out.println(InnerClass.this.innerInt);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，在内部类的里面，我是有内部类和外部类的双重 <code>this</code> 的。对吧？</p><p>另外，对于它们同名的成员变量或者方法，如果我也省略掉 <code>this</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OuterClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> outerInt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> commonInt <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    
    <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> innerInt <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> commonInt <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
        
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>outerInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>innerInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>commonInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>拿到的就是内部类的成员。如果想拿外部类的，就必须把 <code>this</code> 写完整：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>commonInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">OuterClass</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>commonInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>到现在为止，做 Java 的基本是都懂的。我们继续。</p><p>在 Kotlin 里，也是一样的逻辑。只不过写法稍微变了一下：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> OuterClass <span class="token punctuation">{</span>
    <span class="token keyword">var</span> outerInt <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">var</span> commonInt <span class="token operator">=</span> <span class="token number">3</span>

    <span class="token keyword">internal</span> <span class="token keyword">inner</span> <span class="token keyword">class</span> InnerClass <span class="token punctuation">{</span>
        <span class="token keyword">var</span> innerInt <span class="token operator">=</span> <span class="token number">2</span>
        <span class="token keyword">var</span> commonInt <span class="token operator">=</span> <span class="token number">4</span>
        
        <span class="token keyword">fun</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span>outerInt<span class="token punctuation">)</span>
            <span class="token function">println</span><span class="token punctuation">(</span>innerInt<span class="token punctuation">)</span>
            <span class="token function">println</span><span class="token punctuation">(</span>commonInt<span class="token punctuation">)</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token label symbol">@OuterClass</span><span class="token punctuation">.</span>commonInt<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，Java 和 Kotlin 不仅都有 implicit receiver，而且也都是能嵌套的，同一个方法里可以有多个 <code>this</code>，或者说多个 implicit receiver。对吧？</p><p>这是基本概念。</p><h3 id="kotlin-增加的-implicit-receiver-嵌套-通过函数的-receiver-指定" tabindex="-1"><a class="header-anchor" href="#kotlin-增加的-implicit-receiver-嵌套-通过函数的-receiver-指定" aria-hidden="true">#</a> Kotlin 增加的 implicit receiver 嵌套：通过函数的 receiver 指定</h3><p>然后，Kotlin 对于这种嵌套，又新增了一类场景——咱刚才看的是通过内部类来嵌套是吧？Kotlin 让我们还可以直接通过函数来嵌套新的 <code>this</code>。比如你有一个在类型内部声明的扩展函数：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">IntMultiplier</span><span class="token punctuation">(</span><span class="token keyword">var</span> time<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> Int<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token operator">*</span> time
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>——这种函数叫 member extension function，成员扩展函数，其实就是字面意思：它既是成员函数又是扩展函数，对吧？</p><p>这种「成员扩展函数」有一个问题：一方面，因为它是 <code>Int</code> 的扩展函数，所以你需要对 <code>Int</code> 类型的对象才能调用它；但同时，它也是 <code>IntMultiplier</code> 的成员函数，所以你还要求你对 <code>IntMultiplier</code> 对象调用它：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesVPT6wc.jpg" alt=""></p><p>也就是说，这里需要的是个双重 receiver：既要这个直接的 <code>Int</code>，又要那个外部的 <code>IntMultiplier</code>，缺一不可。——那我到底对谁调用？</p><p>Java 没有扩展函数的概念，所以不存在这种写法，但 Kotlin 是可以的。Kotlin 提供的解法是，你专门创建一个函数，并给它设置一个函数类型的参数：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> IntMultiplier <span class="token punctuation">{</span>
    <span class="token keyword">var</span> times <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">fun</span> Int<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span> <span class="token operator">*</span> times
    <span class="token punctuation">}</span>
    
    <span class="token keyword">fun</span> <span class="token function">runAsOuter</span><span class="token punctuation">(</span>block<span class="token operator">:</span> IntMultiplier<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数不用做什么特别的事，关键是执行一下它的那个函数类型的参数</p><p>另外，你要给这个函数类型的参数，设置一个 receiver 的类型</p><p>这么一指定，就把参数的函数体内部——注意，是这个 <code>block</code> 的函数体，不是外部函数本身的函数体——在它内部强行安插了一个隐式的 receiver。换句话说，我在调用这个外部函数的时候，它的函数类型的参数的大括号里就有一个 <code>IntMultiplier</code> 类型的 <code>this</code> 了：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> multiplier <span class="token operator">=</span> <span class="token function">IntMultiplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
multiplier<span class="token punctuation">.</span>times <span class="token operator">=</span> <span class="token number">2</span>
multiplier<span class="token punctuation">.</span><span class="token function">runAsOuter</span> <span class="token punctuation">{</span>
    <span class="token number">3</span><span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哎，就这么通过给参数设置 receiver 的方式，我强行插了一层 <code>this</code>，不用写内部类也实现了这种「双重 <code>this</code>」的环境，是吧？</p><p>但是需要注意，这个 <code>this</code> 它也不是从空气里蹦出来的：当我们这么声明 <code>block</code> 参数的时候，就只有对 <code>IntMultiplier</code> 类型的对象才能调用它。不过咱这个例子里，外部函数正好也是在 <code>IntMultiplier</code> 类里声明的，所以直接写就行：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> IntMultiplier <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">runAsOuter</span><span class="token punctuation">(</span>block<span class="token operator">:</span> IntMultiplier<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 等价于 this.block()，而 this 的类型是 IntMultiplier</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这种结构并不是必须的，你也可以用你能想到的其他方式去写这种安插。比如我可以直接给 <code>Int</code> 写个扩展函数，去插入一个 <code>Int</code> 类型的 <code>this</code>：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> Int<span class="token punctuation">.</span><span class="token function">runAsOuter</span><span class="token punctuation">(</span>block<span class="token operator">:</span> Int<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么我就能把里面这层 <code>this</code> 也做成隐式的了：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>multiplier<span class="token punctuation">.</span><span class="token function">runAsOuter</span> <span class="token punctuation">{</span>
    <span class="token number">3</span><span class="token punctuation">.</span><span class="token function">runAsOuter</span> <span class="token punctuation">{</span>
    	<span class="token function">multiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者我如果不想写成扩展函数，我想把 <code>Int</code> 对象放在参数里来提供，也是行的：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">runAsInt</span><span class="token punctuation">(</span>int<span class="token operator">:</span> Int<span class="token punctuation">,</span> block<span class="token operator">:</span> Int<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	int<span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只要把调用的格式对应地调整一下就可以了：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>multiplier<span class="token punctuation">.</span><span class="token function">runAsOuter</span> <span class="token punctuation">{</span>
    <span class="token function">runAsInt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token function">multiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写法多种多样，但套路是一样的，对吧？</p><p>通过这种写法，我们就可以任意地往代码里插入我们指定的 implicit receiver，或者说指定的 <code>this</code>，去应对「多个 <code>this</code>」的需求场景了。</p><p>而且实际上，Kotlin 已经给我们提供了一套通用的函数。比如我例子里的代码，其实可以直接换成 <code>apply()</code> 和 <code>with()</code>：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>multiplier<span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span>
    <span class="token function">whit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token function">multiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个函数 ，写 Kotlin 的应该很多人都用过吧？但是，也有很多人并不明白它本质上是怎么一回事。实际上，它就是像我刚才说的那样，通过函数类型的参数来强行插入了一层 <code>this</code>。</p><p>不管是使用 Kotlin 现成的函数还是我们自己来实现，Kotlin 允许我们通过这种「指定」的方式来手动安插新的 <code>this</code> 到代码里，而不用非得用内部类才能实现。之前 Java 里嵌套的 <code>this</code>，对应的全都是嵌套的类型结构；而 Kotlin 对能力这么一扩充，<code>this</code> 的嵌套就变得非常自由了。所以，Kotlin 引入了 implicit receiver 的概念，来方便我们对这种扩充了的场景进行描述和沟通。而本质上，所谓的 implicit receiver，指的依然是那些 <code>this</code>——那些不用写的 receiver——这个本质是没有变的。</p><h2 id="协程里的应用" tabindex="-1"><a class="header-anchor" href="#协程里的应用" aria-hidden="true">#</a> 协程里的应用</h2><p>Kotlin 的官方代码，以及很多第三方库，都重度地依赖这个叫做 implicit receiver 的东西。虽然我们可以说「它不就是 <code>this</code> 嘛」，但关键是，它给我们带来了很大的方便，怎么叫其实是次要的。随便举个例子，我们知道协程的启动是一定要用 <code>CoroutineScope</code> 才行的：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>lifecycleScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是为什么在协程的内部再启动新的协程，就不用写 <code>CoroutineScope</code> 了？</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>lifecycleScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
	launch <span class="token punctuation">{</span>
	
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为它有一个隐式的 <code>CoroutineScope</code> 作为 <code>this</code> 被提供了：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesxPdX0J.jpg" alt=""></p><p>怎么提供的？还是一样的方法：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">public</span> <span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>
    context<span class="token operator">:</span> CoroutineContext <span class="token operator">=</span> EmptyCoroutineContext<span class="token punctuation">,</span>
    start<span class="token operator">:</span> CoroutineStart <span class="token operator">=</span> CoroutineStart<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">,</span>
    block<span class="token operator">:</span> <span class="token keyword">suspend</span> CoroutineScope<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit
<span class="token punctuation">)</span><span class="token operator">:</span> Job <span class="token punctuation">{</span>
    <span class="token keyword">val</span> newContext <span class="token operator">=</span> <span class="token function">newCoroutineContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>其他很多官方源码以及第三方库，都有类似的应用，而我们自己也可以在代码里用这样的写法去安插新的 <code>this</code> 层级，或者说——安插 implicit receiver，隐式的 receiver。看起来好像很复杂，但当你明白它的这些本质逻辑，写起来就很简单了。</p>`,78),d={href:"https://rengwuxian.com/implicit-receiver/",target:"_blank",rel:"noopener noreferrer"};function r(k,v){const a=t("ExternalLinkIcon");return p(),c("div",null,[u,s("p",null,[n("本文转自 "),s("a",d,[n("https://rengwuxian.com/implicit-receiver/"),o(a)]),n("，如有侵权，请联系删除。")])])}const b=e(l,[["render",r],["__file","Kotlindechengyuankuozhanhanshuheimplicit_receiver.html.vue"]]);export{b as default};
