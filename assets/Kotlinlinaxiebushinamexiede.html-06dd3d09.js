import{_ as e,r as t,o as p,c as l,b as s,d as n,e as i,a as o}from"./app-e8f85126.js";const c={},d=o(`<h2 id="constructor" tabindex="-1"><a class="header-anchor" href="#constructor" aria-hidden="true">#</a> Constructor</h2><p>上一篇中简单介绍了 Kotlin 的构造器，这一节具体看看 Kotlin 的构造器和 Java 有什么不一样的地方：</p><ul><li><p>Java</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>
      👇   👇
    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Kotlin</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> User <span class="token punctuation">{</span>
    <span class="token keyword">val</span> id<span class="token operator">:</span> Int
    <span class="token keyword">val</span> name<span class="token operator">:</span> String
         👇
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">,</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">//👆 没有 public</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>可以发现有两点不同：</p><ul><li>Java 中构造器和类同名，Kotlin 中使用 <code>constructor</code> 表示。</li><li>Kotlin 中构造器没有 public 修饰，因为默认可见性就是公开的（关于可见性修饰符这里先不展开，后面会讲到）。</li></ul><h3 id="init" tabindex="-1"><a class="header-anchor" href="#init" aria-hidden="true">#</a> init</h3><p>除了构造器，Java 里常常配合一起使用的 init 代码块，在 Kotlin 里的写法也有了一点点改变：你需要给它加一个 <code>init</code> 前缀。</p><ul><li><p>Java</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
   👇
    <span class="token punctuation">{</span>
        <span class="token comment">// 初始化代码块，先于下面的构造器执行</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Kotlin</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> User <span class="token punctuation">{</span>
    👇
    <span class="token keyword">init</span> <span class="token punctuation">{</span>
        <span class="token comment">// 初始化代码块，先于下面的构造器执行</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>正如上面标注的那样，Kotlin 的 init 代码块和 Java 一样，都在实例化时执行，并且执行顺序都在构造器之前。</p><p>上一篇提到，Java 的类如果不加 final 关键字，默认是可以被继承的，而 Kotlin 的类默认就是 final 的。在 Java 里 final 还可以用来修饰变量，接下来让我们看看 Kotlin 是如何实现类似功能的。</p><h2 id="final" tabindex="-1"><a class="header-anchor" href="#final" aria-hidden="true">#</a> <code>final</code></h2><p>Kotlin 中的 <code>val</code> 和 Java 中的 <code>final</code> 类似，表示只读变量，不能修改。这里分别从成员变量、参数和局部变量来和 Java 做对比：</p><ul><li><p>Java</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
 👇
<span class="token keyword">final</span> <span class="token keyword">int</span> final1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
             👇  
<span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> final2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     👇
    <span class="token keyword">final</span> <span class="token class-name">String</span> final3 <span class="token operator">=</span> <span class="token string">&quot;The parameter is &quot;</span> <span class="token operator">+</span> final2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Kotlin</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
👇
<span class="token keyword">val</span> fina1 <span class="token operator">=</span> <span class="token number">1</span>
       <span class="token comment">// 👇 参数是没有 val 的</span>
<span class="token keyword">fun</span> <span class="token function">method</span><span class="token punctuation">(</span>final2<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    👇
    <span class="token keyword">val</span> final3 <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;The parameter is &quot;</span></span> <span class="token operator">+</span> final2
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>可以看到不同点主要有：</p><ul><li>final 变成了 val。</li><li>Kotlin 函数参数默认是 val 类型，所以参数前不需要写 val 关键字，Kotlin 里这样设计的原因是保证了参数不会被修改，而 Java 的参数可修改（默认没 final 修饰）会增加出错的概率。</li></ul><p>上一期说过，<code>var</code> 是 variable 的缩写， <code>val</code> 是 value 的缩写。</p><p>其实我们写 Java 代码的时候，很少会有人用 <code>final</code>，但 <code>final</code> 用来修饰变量其实是很有用的，但大家都不用；可你如果去看看国内国外的人写的 Kotlin 代码，你会发现很多人的代码里都会有一堆的 <code>val</code>。为什么？因为 <code>final</code> 写起来比 <code>val</code> 麻烦一点：我需要多写一个单词。虽然只麻烦这一点点，但就导致很多人不写。</p><p>这就是一件很有意思的事：从 <code>final</code> 到 <code>val</code>，只是方便了一点点，但却让它的使用频率有了巨大的改变。这种改变是会影响到代码质量的：在该加限制的地方加上限制，就可以减少代码出错的概率。</p><h3 id="val自定义-getter" tabindex="-1"><a class="header-anchor" href="#val自定义-getter" aria-hidden="true">#</a> <code>val</code>自定义 getter</h3><p>不过 <code>val</code> 和 <code>final</code> 还是有一点区别的，虽然 <code>val</code> 修饰的变量不能二次赋值，但可以通过自定义变量的 getter 函数，让变量每次被访问时，返回动态获取的值：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
👇
<span class="token keyword">val</span> size<span class="token operator">:</span> Int
    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 👈 每次获取 size 值时都会执行 items.size</span>
        <span class="token keyword">return</span> items<span class="token punctuation">.</span>size
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过这个属于 <code>val</code> 的另外一种用法，大部分情况下 <code>val</code> 还是对应于 Java 中的 <code>final</code> 使用的。</p><h2 id="static-property-function" tabindex="-1"><a class="header-anchor" href="#static-property-function" aria-hidden="true">#</a> <code>static</code> property / function</h2><p>刚才说到大家都不喜欢写 <code>final</code> 对吧？但有一种场景，大家是最喜欢用 <code>final</code> 的：常量。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">CONST_STRING</span> <span class="token operator">=</span> <span class="token string">&quot;A String&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Java 里面写常量，我们用的是 <code>static</code> + <code>final</code>。而在 Kotlin 里面，除了 <code>final</code> 的写法不一样，<code>static</code> 的写法也不一样，而且是更不一样。确切地说：在 <code>Kotlin</code> 里，静态变量和静态方法这两个概念被去除了。</p><p>那如果想在 Kotlin 中像 Java 一样通过类直接引用该怎么办呢？Kotlin 的答案是 <code>companion object</code>：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> Sample <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
       👇
    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>
        <span class="token keyword">val</span> anotherString <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Another String&quot;</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为啥 Kotlin 越改越复杂了？不着急，我们先看看 <code>object</code> 是个什么东西。</p><h3 id="object" tabindex="-1"><a class="header-anchor" href="#object" aria-hidden="true">#</a> <code>object</code></h3><p>Kotlin 里的 <code>object</code> ——首字母小写的，不是大写，Java 里的 <code>Object</code> 在 Kotlin 里不用了。</p><blockquote><p>Java 中的 <code>Object</code> 在 Kotlin 中变成了 <code>Any</code>，和 <code>Object</code> 作用一样：作为所有类的基类。</p></blockquote><p>而 <code>object</code> 不是类，像 <code>class</code> 一样在 Kotlin 中属于关键字：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">object</span> Sample <span class="token punctuation">{</span>
    <span class="token keyword">val</span> name <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;A name&quot;</span></span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的意思很直接：创建一个类，并且创建一个这个类的对象。这个就是 <code>object</code> 的意思：对象。</p><p>在代码中如果要使用这个对象，直接通过它的类名就可以访问：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
Sample<span class="token punctuation">.</span>name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这不就是单例么，所以在 Kotlin 中创建单例不用像 Java 中那么复杂，只需要把 <code>class</code> 换成 <code>object</code> 就可以了。</p><ul><li><p>单例类</p><p>我们看一个单例的例子，分别用 Java 和 Kotlin 实现：</p><ul><li><p>Java 中实现单例类（非线程安全）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">A</span> sInstance<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">A</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sInstance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 👇还有很多模板代码</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到 Java 中为了实现单例类写了大量的模版代码，稍显繁琐。</p></li><li><p>Kotlin 中实现单例类：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code> 🏝️
<span class="token comment">// 👇 class 替换成了 object</span>
<span class="token keyword">object</span> A <span class="token punctuation">{</span>
    <span class="token keyword">val</span> number<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">fun</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;A.method()&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和 Java 相比的不同点有：</p><ul><li>和类的定义类似，但是把 <code>class</code> 换成了 <code>object</code> 。</li><li>不需要额外维护一个实例变量 <code>sInstance</code>。</li><li>不需要「保证实例只创建一次」的 <code>getInstance()</code> 方法。</li></ul><p>相比 Java 的实现简单多了。</p><blockquote><p>这种通过 <code>object</code> 实现的单例是一个饿汉式的单例，并且实现了线程安全。</p></blockquote></li></ul></li><li><p>继承类和实现接口</p><p>Kotlin 中不仅类可以继承别的类，可以实现接口，<code>object</code> 也可以：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">open</span> <span class="token keyword">class</span> A <span class="token punctuation">{</span>
    <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> B <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">interfaceMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
  👇      👇   👇
<span class="token keyword">object</span> C <span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> B <span class="token punctuation">{</span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">interfaceMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么 object 可以实现接口呢？简单来讲 object 其实是把两步合并成了一步，既有 class 关键字的功能，又实现了单例，这样就容易理解了。</p></li><li><p>匿名类</p><p>另外，Kotlin 还可以创建 Java 中的匿名类，只是写法上有点不同：</p><ul><li><p>Java：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️                                              👇 
<span class="token class-name">ViewPager<span class="token punctuation">.</span>SimpleOnPageChangeListener</span> listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ViewPager<span class="token punctuation">.</span>SimpleOnPageChangeListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span> <span class="token comment">// 👈</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPageSelected</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// override</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Kotlin：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️          
<span class="token keyword">val</span> listener <span class="token operator">=</span> <span class="token keyword">object</span><span class="token operator">:</span> ViewPager<span class="token punctuation">.</span><span class="token function">SimpleOnPageChangeListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onPageSelected</span><span class="token punctuation">(</span>position<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// override</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>        
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和 Java 创建匿名类的方式很相似，只不过把 <code>new</code> 换成了 <code>object:</code>：</p><ul><li>Java 中 <code>new</code> 用来创建一个匿名类的对象</li><li>Kotlin 中 <code>object:</code> 也可以用来创建匿名类的对象</li></ul><p>这里的 <code>new</code> 和 <code>object:</code> 修饰的都是接口或者抽象类。</p></li></ul></li></ul><h3 id="companion-object" tabindex="-1"><a class="header-anchor" href="#companion-object" aria-hidden="true">#</a> <code>companion object</code></h3><p>用 <code>object</code> 修饰的对象中的变量和函数都是静态的，但有时候，我们只想让类中的一部分函数和变量是静态的该怎么做呢：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> A <span class="token punctuation">{</span>
          👇
    <span class="token keyword">object</span> B <span class="token punctuation">{</span>
        <span class="token keyword">var</span> c<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上，可以在类中创建一个对象，把需要静态的变量或函数放在内部对象 B 中，外部可以通过如下的方式调用该静态变量：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
A<span class="token punctuation">.</span>B<span class="token punctuation">.</span>c
  👆
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类中嵌套的对象可以用 <code>companion</code> 修饰：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> A <span class="token punctuation">{</span>
       👇
    <span class="token keyword">companion</span> <span class="token keyword">object</span> B <span class="token punctuation">{</span>
        <span class="token keyword">var</span> c<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>companion</code> 可以理解为伴随、伴生，表示修饰的对象和外部类绑定。</p><p>但这里有一个小限制：一个类中最多只可以有一个伴生对象，但可以有多个嵌套对象。就像皇帝后宫佳丽三千，但皇后只有一个。</p><p>这样的好处是调用的时候可以省掉对象名：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
A<span class="token punctuation">.</span>c <span class="token comment">// 👈 B 没了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，当有 <code>companion</code> 修饰时，对象的名字也可以省略掉：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> A <span class="token punctuation">{</span>
                <span class="token comment">// 👇 B 没了</span>
    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> c<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就是这节最开始讲到的，Java 静态变量和方法的等价写法：<code>companion object</code> 变量和函数。</p><ul><li><p>静态初始化</p><p>Java 中的静态变量和方法，在 Kotlin 中都放在了 <code>companion object</code> 中。因此 Java 中的静态初始化在 Kotlin 中自然也是放在 <code>companion object</code> 中的，像类的初始化代码一样，由 <code>init</code> 和一对大括号表示：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> Sample <span class="token punctuation">{</span>
       👇
    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>
         👇
        <span class="token keyword">init</span> <span class="token punctuation">{</span>
            <span class="token operator">..</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="top-level-property-function-声明" tabindex="-1"><a class="header-anchor" href="#top-level-property-function-声明" aria-hidden="true">#</a> top-level property / function 声明</h3><p>除了静态函数这种简便的调用方式，Kotlin 还有更方便的东西：「<code>top-level declaration</code> 顶层声明」。其实就是把属性和函数的声明不写在 <code>class</code> 里面，这个在 Kotlin 里是允许的：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">package</span> com<span class="token punctuation">.</span>hencoder<span class="token punctuation">.</span>plus

<span class="token comment">// 👇 属于 package，不在 class/object 内</span>
<span class="token keyword">fun</span> <span class="token function">topLevelFuncion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样写的属性和函数，不属于任何 <code>class</code>，而是直接属于 <code>package</code>，它和静态变量、静态函数一样是全局的，但用起来更方便：你在其它地方用的时候，就连类名都不用写：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">import</span> com<span class="token punctuation">.</span>hencoder<span class="token punctuation">.</span>plus<span class="token punctuation">.</span>topLevelFunction <span class="token comment">// 👈 直接 import 函数</span>

<span class="token function">topLevelFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写在顶级的函数或者变量有个好处：在 Android Studio 中写代码时，IDE 很容易根据你写的函数前几个字母自动联想出相应的函数。这样提高了写代码的效率，而且可以减少项目中的重复代码。</p><ul><li><p>命名相同的顶级函数</p><p>顶级函数不写在类中可能有一个问题：如果在不同文件中声明命名相同的函数，使用的时候会不会混淆？来看一个例子：</p><ul><li><p>在 <code>org.kotlinmaster.library</code> 包下有一个函数 method：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">package</span> org<span class="token punctuation">.</span>kotlinmaster<span class="token punctuation">.</span>library1
                           👆
<span class="token keyword">fun</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;library1 method()&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在 <code>org.kotlinmaster.library2</code> 包下有一个同名函数：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">package</span> org<span class="token punctuation">.</span>kotlinmaster<span class="token punctuation">.</span>library2
                           👆
<span class="token keyword">fun</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;library2 method()&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>在使用的时候如果同时调用这两个同名函数会怎么样：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">import</span> org<span class="token punctuation">.</span>kotlinmaster<span class="token punctuation">.</span>library1<span class="token punctuation">.</span>method
                           👆
<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                       👇
    org<span class="token punctuation">.</span>kotlinmaster<span class="token punctuation">.</span>library2<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到当出现两个同名顶级函数时，IDE 会自动加上包前缀来区分，这也印证了「顶级函数属于包」的特性。</p></li></ul><h3 id="对比" tabindex="-1"><a class="header-anchor" href="#对比" aria-hidden="true">#</a> 对比</h3><p>那在实际使用中，在 <code>object</code>、<code>companion object</code> 和 top-level 中该选择哪一个呢？简单来说按照下面这两个原则判断：</p><ul><li>如果想写工具类的功能，直接创建文件，写 top-level「顶层」函数。</li><li>如果需要继承别的类或者实现接口，就用 <code>object</code> 或 <code>companion object</code>。</li></ul><h2 id="常量" tabindex="-1"><a class="header-anchor" href="#常量" aria-hidden="true">#</a> 常量</h2><p>Java 中，除了上面讲到的的静态变量和方法会用到 <code>static</code>，声明常量时也会用到，那 Kotlin 中声明常量会有什么变化呢？</p><ul><li><p>Java 中声明常量：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span>
            👇     👇
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CONST_NUMBER</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Kotlin 中声明常量：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> Sample <span class="token punctuation">{</span>
    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>
         👇                  <span class="token comment">// 👇</span>
        <span class="token keyword">const</span> <span class="token keyword">val</span> CONST_NUMBER <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token keyword">val</span> CONST_SECOND_NUMBER <span class="token operator">=</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>发现不同点有：</p><ul><li>Kotlin 的常量必须声明在对象（包括伴生对象）或者「top-level 顶层」中，因为常量是静态的。</li><li>Kotlin 新增了修饰常量的 <code>const</code> 关键字。</li></ul><p>除此之外还有一个区别：</p><ul><li>Kotlin 中只有基本类型和 String 类型可以声明成常量。</li></ul><p>原因是 Kotlin 中的常量指的是 「compile-time constant 编译时常量」，它的意思是「编译器在编译的时候就知道这个东西在每个调用处的实际值」，因此可以在编译时直接把这个值硬编码到代码里使用的地方。</p><p>而非基本和 String 类型的变量，可以通过调用对象的方法或变量改变对象内部的值，这样这个变量就不是常量了，来看一个 Java 的例子，比如一个 User 类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span> <span class="token comment">// 👈 可修改</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span> <span class="token comment">// 👈 可修改</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用的地方声明一个 <code>static final</code> 的 User 实例 <code>user</code>，它是不能二次赋值的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">&quot;Zhangsan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  👆    👆
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是可以通过访问这个 <code>user</code> 实例的成员变量改变它的值：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Lisi&quot;</span><span class="token punctuation">;</span>
      👆
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以 Java 中的常量可以认为是「伪常量」，因为可以通过上面这种方式改变它内部的值。而 Kotlin 的常量因为限制类型必须是基本类型，所以不存在这种问题，更符合常量的定义。</p><p>前面讲的 <code>val</code> 「只读变量」和静态变量都是针对单个变量来说的，接下来我们看看编程中另外一个常见的主题：数组和集合。</p><h2 id="数组和集合" tabindex="-1"><a class="header-anchor" href="#数组和集合" aria-hidden="true">#</a> 数组和集合</h2><h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h3><p>声明一个 String 数组：</p><ul><li><p>Java 中的写法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
      👆        👆
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Kotlin 中的写法：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">val</span> strs<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;a&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;b&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;c&quot;</span></span><span class="token punctuation">)</span>
            👆              👆
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>可以看到 Kotlin 中的数组是一个拥有泛型的类，创建函数也是泛型函数，和集合数据类型一样。</p><blockquote><p>针对泛型的知识点，我们在后面的文章会讲，这里就先按照 Java 泛型来理解。</p></blockquote><p>将数组泛型化有什么好处呢？对数组的操作可以像集合一样功能更强大，由于泛型化，Kotlin 可以给数组增加很多有用的工具函数：</p><ul><li><code>get() / set()</code></li><li><code>contains()</code></li><li><code>first()</code></li><li><code>find()</code></li></ul><p>这样数组的实用性就大大增加了。</p><ul><li><p>取值和修改</p><p>Kotlin 中获取或者设置数组元素和 Java 一样，可以使用方括号加下标的方式索引：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token function">println</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
   👇      👆
strs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;B&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>不支持协变</p><p>Kotlin 的数组编译成字节码时使用的仍然是 Java 的数组，但在语言层面是泛型实现，这样会失去协变 (covariance) 特性，就是子类数组对象不能赋值给父类的数组变量：</p><ul><li><p>Kotlin</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">val</span> strs<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;a&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;b&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;c&quot;</span></span><span class="token punctuation">)</span>
                  👆
<span class="token keyword">val</span> anys<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Any<span class="token operator">&gt;</span> <span class="token operator">=</span> strs <span class="token comment">// compile-error: Type mismatch</span>
                👆
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>而这在 Java 中是可以的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  👆
<span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objs <span class="token operator">=</span> strs<span class="token punctuation">;</span> <span class="token comment">// success</span>
  👆
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>关于协变的问题，这里就先不展开了，后面讲泛型的时候会提到。</p></li></ul><h3 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h3><p>Kotlin 和 Java 一样有三种集合类型：List、Set 和 Map，它们的含义分别如下：</p><ul><li><code>List</code> 以固定顺序存储一组元素，元素可以重复。</li><li><code>Set</code> 存储一组互不相等的元素，通常没有固定顺序。</li><li><code>Map</code> 存储 键-值 对的数据集合，键互不相等，但不同的键可以对应相同的值。</li></ul><p>从 Java 到 Kotlin，这三种集合类型的使用有哪些变化呢？我们依次看看。</p><ul><li><p>List</p><ul><li><p>Java 中创建一个列表：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> strList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
strList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
strList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
strList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 👈 添加元素繁琐</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Kotlin 中创建一个列表：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️            
<span class="token keyword">val</span> strList <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;a&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;b&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;c&quot;</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>首先能看到的是 Kotlin 中创建一个 <code>List</code> 特别的简单，有点像创建数组的代码。而且 Kotlin 中的 <code>List</code> 多了一个特性：支持 covariant（协变）。也就是说，可以把子类的 <code>List</code> 赋值给父类的 <code>List</code> 变量：</p><ul><li><p>Kotlin：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">val</span> strs<span class="token operator">:</span> List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;a&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;b&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;c&quot;</span></span><span class="token punctuation">)</span>
                👆
<span class="token keyword">val</span> anys<span class="token operator">:</span> List<span class="token operator">&lt;</span>Any<span class="token operator">&gt;</span> <span class="token operator">=</span> strs <span class="token comment">// success</span>
               👆
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>而这在 Java 中是会报错的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> strList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       👆
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> objList <span class="token operator">=</span> strList<span class="token punctuation">;</span> <span class="token comment">// 👈 compile error: incompatible types</span>
      👆  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>对于协变的支持与否，<code>List</code> 和数组刚好反过来了。关于协变，这里只需结合例子简单了解下，后面的文章会对它展开讨论。</p></li><li><p>和数组的区别</p><p>Kotlin 中数组和 MutableList 的 API 是非常像的，主要的区别是数组的元素个数不能变。那在什么时候用数组呢？</p><ul><li><p>这个问题在 Java 中就存在了，数组和 <code>List</code> 的功能类似，<code>List</code> 的功能更多一些，直觉上应该用 <code>List</code> 。但数组也不是没有优势，基本类型 (<code>int[]</code>、<code>float[]</code>) 的数组不用自动装箱，性能好一点。</p></li><li><p>在 Kotlin 中也是同样的道理，在一些性能需求比较苛刻的场景，并且元素类型是基本类型时，用数组好一点。不过这里要注意一点，Kotlin 中要用专门的基本类型数组类 (<code>IntArray</code> <code>FloatArray</code> <code>LongArray</code>) 才可以免于装箱。也就是说元素不是基本类型时，相比 <code>Array</code>，用 <code>List</code> 更方便些。</p></li></ul></li><li><p>Set</p><ul><li><p>Java 中创建一个 <code>Set</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> strSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
strSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
strSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
strSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Kotlin 中创建相同的 <code>Set</code>：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️           
<span class="token keyword">val</span> strSet <span class="token operator">=</span> <span class="token function">setOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;a&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;b&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;c&quot;</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>和 <code>List</code> 类似，<code>Set</code> 同样具有 covariant（协变）特性。</p></li><li><p>Map</p><ul><li><p>Java 中创建一个 <code>Map</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;key1&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;key2&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;key3&quot;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;key4&quot;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Kotlin 中创建一个 <code>Map</code>：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️         
<span class="token keyword">val</span> map <span class="token operator">=</span> <span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;key1&quot;</span></span> <span class="token keyword">to</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;key2&quot;</span></span> <span class="token keyword">to</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;key3&quot;</span></span> <span class="token keyword">to</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;key4&quot;</span></span> <span class="token keyword">to</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>和上面两种集合类型相似创建代码很简洁。<code>mapOf</code> 的每个参数表示一个键值对，<code>to</code> 表示将「键」和「值」关联，这个叫做「中缀表达式」，这里先不展开，后面的文章会做介绍。</p><ul><li><p>取值和修改</p><ul><li><p>Kotlin 中的 Map 除了和 Java 一样可以使用 <code>get()</code> 根据键获取对应的值，还可以使用方括号的方式获取：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
                 👇
<span class="token keyword">val</span> value1 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;key1&quot;</span></span><span class="token punctuation">)</span>
               👇
<span class="token keyword">val</span> value2 <span class="token operator">=</span> map<span class="token punctuation">[</span><span class="token string-literal singleline"><span class="token string">&quot;key2&quot;</span></span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>类似的，Kotlin 中也可以用方括号的方式改变 <code>Map</code> 中键对应的值：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️       
              👇
<span class="token keyword">val</span> map <span class="token operator">=</span> <span class="token function">mutableMapOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;key1&quot;</span></span> <span class="token keyword">to</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;key2&quot;</span></span> <span class="token keyword">to</span> <span class="token number">2</span><span class="token punctuation">)</span>
    👇
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;key1&quot;</span></span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
   👇
map<span class="token punctuation">[</span><span class="token string-literal singleline"><span class="token string">&quot;key1&quot;</span></span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>这里用到了「操作符重载」的知识，实现了和数组一样的「Positional Access Operations」，关于这个概念这里先不展开，后面会讲到。</p></li></ul></li><li><p>可变集合/不可变集合</p><p>上面修改 <code>Map</code> 值的例子中，创建函数用的是 <code>mutableMapOf()</code> 而不是 <code>mapOf()</code>，因为只有 <code>mutableMapOf()</code> 创建的 <code>Map</code> 才可以修改。Kotlin 中集合分为两种类型：只读的和可变的。这里的只读有两层意思：</p><ul><li>集合的 size 不可变</li><li>集合中的元素值不可变</li></ul><p>以下是三种集合类型创建不可变和可变实例的例子：</p><ul><li><code>listOf()</code> 创建不可变的 <code>List</code>，<code>mutableListOf()</code> 创建可变的 <code>List</code>。</li><li><code>setOf()</code> 创建不可变的 <code>Set</code>，<code>mutableSetOf()</code> 创建可变的 <code>Set</code>。</li><li><code>mapOf()</code> 创建不可变的 <code>Map</code>，<code>mutableMapOf()</code> 创建可变的 <code>Map</code>。</li></ul><p>可以看到，有 <code>mutable</code> 前缀的函数创建的是可变的集合，没有 <code>mutbale</code> 前缀的创建的是不可变的集合，不过不可变的可以通过 <code>toMutable*()</code> 系函数转换成可变的集合：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">val</span> strList <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;a&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;b&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;c&quot;</span></span><span class="token punctuation">)</span>
            👇
strList<span class="token punctuation">.</span><span class="token function">toMutableList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> strSet <span class="token operator">=</span> <span class="token function">setOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;a&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;b&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;c&quot;</span></span><span class="token punctuation">)</span>
            👇
strSet<span class="token punctuation">.</span><span class="token function">toMutableSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> map <span class="token operator">=</span> <span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;key1&quot;</span></span> <span class="token keyword">to</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;key2&quot;</span></span> <span class="token keyword">to</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;key3&quot;</span></span> <span class="token keyword">to</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;key4&quot;</span></span> <span class="token keyword">to</span> <span class="token number">3</span><span class="token punctuation">)</span>
         👇
map<span class="token punctuation">.</span><span class="token function">toMutableMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就可以对集合进行修改了，这里有一点需要注意下：</p><ul><li><code>toMutable*()</code> 返回的是一个新建的集合，原有的集合还是不可变的，所以只能对函数返回的集合修改。</li></ul></li></ul><h3 id="sequence" tabindex="-1"><a class="header-anchor" href="#sequence" aria-hidden="true">#</a> <code>Sequence</code></h3><p>除了集合 Kotlin 还引入了一个新的容器类型 <code>Sequence</code>，它和 <code>Iterable</code> 一样用来遍历一组数据并可以对每个元素进行特定的处理，先来看看如何创建一个 <code>Sequence</code>。</p><ul><li>创建 <ul><li><p>类似 <code>listOf()</code> ，使用一组元素创建：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token function">sequenceOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;a&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;b&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;c&quot;</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>使用 <code>Iterable</code> 创建：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;a&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;b&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;c&quot;</span></span><span class="token punctuation">)</span>
list<span class="token punctuation">.</span><span class="token function">asSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 <code>List</code> 实现了 <code>Iterable</code> 接口。</p></li><li><p>使用 lambda 表达式创建：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️                          <span class="token comment">// 👇 第一个元素</span>
<span class="token keyword">val</span> sequence <span class="token operator">=</span> <span class="token function">generateSequence</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> it <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span>
                                  <span class="token comment">// 👆 lambda 表达式，负责生成第二个及以后的元素，it 表示前一个元素</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><p>这看起来和 <code>Iterable</code> 一样呀，为啥要多此一举使用 <code>Sequence</code> 呢？在下一篇文章中会结合例子展开讨论。</p><h2 id="可见性修饰符" tabindex="-1"><a class="header-anchor" href="#可见性修饰符" aria-hidden="true">#</a> 可见性修饰符</h2><p>讲完了数据集合，再看看 Kotlin 中的可见性修饰符，Kotlin 中有四种可见性修饰符：</p><ul><li><code>public</code> ：公开，可见性最大，哪里都可以引用。</li><li><code>private</code>：私有，可见性最小，根据声明位置不同可分为类中可见和文件中可见。</li><li><code>protected</code>：保护，相当于 <code>private</code> + 子类可见。</li><li><code>internal</code>：内部，仅对 module 内可见。</li></ul><p>相比 Java 少了一个 <code>default</code> 「包内可见」修饰符，多了一个 <code>internal</code>「module 内可见」修饰符。这一节结合例子讲讲 Kotlin 这四种可见性修饰符，以及在 Kotlin 和 Java 中的不同。先来看看 <code>public</code>：</p><h3 id="public" tabindex="-1"><a class="header-anchor" href="#public" aria-hidden="true">#</a> <code>public</code></h3><p>Java 中没写可见性修饰符时，表示包内可见，只有在同一个 <code>package</code> 内可以引用：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️                         👇
<span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>kotlinmaster<span class="token punctuation">.</span>library</span><span class="token punctuation">;</span> 
<span class="token comment">// 没有可见性修饰符</span>
<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️                      <span class="token comment">// 👇 和上面同一个 package</span>
<span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>kotlinmaster<span class="token punctuation">.</span>library</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// success</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>kotlinmaster</span><span class="token punctuation">;</span>
                    <span class="token comment">// 👆 和上面不是一个 package</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>kotlinmaster<span class="token punctuation">.</span>library<span class="token punctuation">.</span></span><span class="token class-name">User</span></span><span class="token punctuation">;</span>
                          👆
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OtherPackageExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// compile-error: &#39;org.kotlinmaster.library.User&#39; is not public in &#39;org.kotlinmaster.library&#39;. Cannot be accessed from outside package</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>package</code> 外如果要引用，需要在 <code>class</code> 前加上可见性修饰符 <code>public</code> 表示公开。</p><p>Kotlin 中如果不写可见性修饰符，就表示公开，和 Java 中 <code>public</code> 修饰符具有相同效果。在 Kotlin 中 <code>public</code> 修饰符「可以加，但没必要」。</p><h3 id="hide" tabindex="-1"><a class="header-anchor" href="#hide" aria-hidden="true">#</a> <code>@hide</code></h3><p>在 Android 的官方 sdk 中，有一些方法只想对 sdk 内可见，不想开放给用户使用（因为这些方法不太稳定，在后续版本中很有可能会修改或删掉）。为了实现这个特性，会在方法的注释中添加一个 Javadoc 方法 <code>@hide</code>，用来限制客户端访问：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token doc-comment comment">/**
* <span class="token keyword">@hide</span> 👈
*/</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hideMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这种限制不太严格，可以通过反射访问到限制的方法。针对这个情况，Kotlin 引进了一个更为严格的可见性修饰符：<code>internal</code>。</p><h3 id="internal" tabindex="-1"><a class="header-anchor" href="#internal" aria-hidden="true">#</a> <code>internal</code></h3><p><code>internal</code> 表示修饰的类、函数仅对 module 内可见，这里的 module 具体指的是一组共同编译的 kotlin 文件，常见的形式有：</p><ul><li>Android Studio 里的 module</li><li>Maven project</li></ul><blockquote><p>我们常见的是 Android Studio 中的 module 这种情况，Maven project 仅作了解就好，不用细究。</p></blockquote><p><code>internal</code> 在写一个 library module 时非常有用，当需要创建一个函数仅开放给 module 内部使用，不想对 library 的使用者可见，这时就应该用 <code>internal</code> 可见性修饰符。</p><h3 id="java-的「包内可见」怎么没了" tabindex="-1"><a class="header-anchor" href="#java-的「包内可见」怎么没了" aria-hidden="true">#</a> Java 的「包内可见」怎么没了？</h3><p>Java 的 <code>default</code>「包内可见」在 Kotlin 中被弃用掉了，Kotlin 中与它最接近的可见性修饰符是 <code>internal</code>「module 内可见」。为什么会弃用掉包内可见呢？我觉得有这几个原因：</p><ul><li>Kotlin 鼓励创建 top-level 函数和属性，一个源码文件可以包含多个类，使得 Kotlin 的源码结构更加扁平化，包结构不再像 Java 中那么重要。</li><li>为了代码的解耦和可维护性，module 越来越多、越来越小，使得 <code>internal</code> 「module 内可见」已经可以满足对于代码封装的需求。</li></ul><h3 id="protected" tabindex="-1"><a class="header-anchor" href="#protected" aria-hidden="true">#</a> <code>protected</code></h3><ul><li>Java 中 <code>protected</code> 表示包内可见 + 子类可见。</li><li>Kotlin 中 <code>protected</code> 表示 <code>private</code> + 子类可见。</li></ul><p>Kotlin 相比 Java <code>protected</code> 的可见范围收窄了，原因是 Kotlin 中不再有「包内可见」的概念了，相比 Java 的可见性着眼于 <code>package</code>，Kotlin 更关心的是 module。</p><h3 id="private" tabindex="-1"><a class="header-anchor" href="#private" aria-hidden="true">#</a> <code>private</code></h3><ul><li>Java 中的 <code>private</code> 表示类中可见，作为内部类时对外部类「可见」。</li><li>Kotlin 中的 <code>private</code> 表示类中或所在文件内可见，作为内部类时对外部类「不可见」。</li></ul><p><code>private</code> 修饰的变量「类中可见」和 「文件中可见」:</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> Sample <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> propertyInClass <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 👈 仅 Sample 类中可见</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">val</span> propertyInFile <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;A string.&quot;</span></span> <span class="token comment">// 👈 范围更大，整个文件可见</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>private</code> 修饰内部类的变量时，在 Java 和 Kotlin 中的区别：</p><ul><li><p>在 Java 中，外部类可以访问内部类的 <code>private</code> 变量：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outter</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Inner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            👇
        <span class="token keyword">int</span> result <span class="token operator">=</span> inner<span class="token punctuation">.</span>number <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// success</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在 Kotlin 中，外部类不可以访问内部类的 <code>private</code> 变量：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> Outter <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">val</span> <span class="token keyword">inner</span> <span class="token operator">=</span> <span class="token function">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                            👇
        <span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token keyword">inner</span><span class="token punctuation">.</span>number <span class="token operator">*</span> <span class="token number">2</span> <span class="token comment">// compile-error: Cannot access &#39;number&#39;: it is private in &#39;Inner&#39;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">class</span> Inner <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">val</span> number <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>可以修饰类和接口</p><ul><li><p>Java 中一个文件只允许一个外部类，所以 <code>class</code> 和 <code>interface</code> 不允许设置为 <code>private</code>，因为声明 <code>private</code> 后无法被外部使用，这样就没有意义了。</p></li><li><p>Kotlin 允许同一个文件声明多个 <code>class</code> 和 top-level 的函数和属性，所以 Kotlin 中允许类和接口声明为 <code>private</code>，因为同个文件中的其它成员可以访问：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️                   
<span class="token keyword">private</span> <span class="token keyword">class</span> Sample <span class="token punctuation">{</span>
    <span class="token keyword">val</span> number <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">fun</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Sample method()&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
            <span class="token comment">// 👇 在同一个文件中，所以可以访问</span>
<span class="token keyword">val</span> sample <span class="token operator">=</span> <span class="token function">Sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul>`,131),u={href:"https://rengwuxian.com/kotlin-basic-2/",target:"_blank",rel:"noopener noreferrer"};function r(k,v){const a=t("ExternalLinkIcon");return p(),l("div",null,[d,s("p",null,[n("本文转自 "),s("a",u,[n("https://rengwuxian.com/kotlin-basic-2/"),i(a)]),n("，如有侵权，请联系删除。")])])}const b=e(c,[["render",r],["__file","Kotlinlinaxiebushinamexiede.html.vue"]]);export{b as default};
