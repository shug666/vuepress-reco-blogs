import{_ as a,r as d,o as c,c as r,b as o,d as e,e as n,a as l}from"./app-e8f85126.js";const t={},s=l('<p>自定义 View 最关键的有三个点：绘制、布局和触摸反馈</p><h2 id="布局过程的含义" tabindex="-1"><a class="header-anchor" href="#布局过程的含义" aria-hidden="true">#</a> 布局过程的含义</h2><p>布局过程，就是程序在运行时利用布局文件的代码来计算出实际尺寸的过程。</p><h2 id="布局过程的工作内容" tabindex="-1"><a class="header-anchor" href="#布局过程的工作内容" aria-hidden="true">#</a> 布局过程的工作内容</h2><p>两个阶段：测量阶段和布局阶段。</p><p><strong>测量阶段</strong>：从上到下递归地调用每个 View 或者 ViewGroup 的 measure() 方法，测量他们的尺寸并计算它们的位置；</p><p><strong>布局阶段</strong>：从上到下递归地调用每个 View 或者 ViewGroup 的 layout() 方法，把测得的它们的尺寸和位置赋值给它们。</p><h2 id="view-或-viewgroup-的布局过程" tabindex="-1"><a class="header-anchor" href="#view-或-viewgroup-的布局过程" aria-hidden="true">#</a> View 或 ViewGroup 的布局过程</h2><p>1.测量阶段，<code>measure()</code> 方法被父 View 调用，在 <code>measure()</code> 中做一些准备和优化工作后，调用 <code>onMeasure()</code> 来进行实际的自我测量。 <code>onMeasure()</code> 做的事，<code>View</code> 和 <code>ViewGroup</code> 不一样：</p><ol><li><strong>View</strong>：<code>View</code> 在 <code>onMeasure()</code> 中会计算出自己的尺寸然后保存；</li><li><strong>ViewGroup</strong>：<code>ViewGroup</code> 在 <code>onMeasure()</code> 中会调用所有子 View 的 <code>measure()</code> 让它们进行自我测量，并根据子 View 计算出的期望尺寸来计算出它们的实际尺寸和位置（实际上 99.99% 的父 View 都会使用子 View 给出的期望尺寸来作为实际尺寸，原因在下期或下下期会讲到）然后保存。同时，它也会根据子 View 的尺寸和位置来计算出自己的尺寸然后保存；</li></ol><p>2.布局阶段，<code>layout()</code> 方法被父 View 调用，在 <code>layout()</code> 中它会保存父 View 传进来的自己的位置和尺寸，并且调用 <code>onLayout()</code> 来进行实际的内部布局。<code>onLayout()</code> 做的事， <code>View</code> 和 <code>ViewGroup</code> 也不一样：</p><ol><li><strong>View</strong>：由于没有子 View，所以 <code>View</code> 的 <code>onLayout()</code> 什么也不做。</li><li><strong>ViewGroup</strong>：<code>ViewGroup</code> 在 <code>onLayout()</code> 中会调用自己的所有子 View 的 <code>layout()</code> 方法，把它们的尺寸和位置传给它们，让它们完成自我的内部布局。</li></ol><h2 id="布局过程自定义的方式" tabindex="-1"><a class="header-anchor" href="#布局过程自定义的方式" aria-hidden="true">#</a> 布局过程自定义的方式</h2><p>三类：</p><ol><li>重写 <code>onMeasure()</code> 来修改已有的 <code>View</code> 的尺寸；</li><li>重写 <code>onMeasure()</code> 来全新定制自定义 <code>View</code> 的尺寸；</li><li>重写 <code>onMeasure()</code> 和 <code>onLayout()</code> 来全新定制自定义 <code>ViewGroup</code> 的内部布局。</li></ol><h2 id="_1-修改已有自定义view的尺寸" tabindex="-1"><a class="header-anchor" href="#_1-修改已有自定义view的尺寸" aria-hidden="true">#</a> 1. 修改已有自定义View的尺寸</h2><p>也就是重写 <code>onMeasure()</code> 来修改已有的 <code>View</code> 的尺寸的具体做法：</p><ol><li>重写 <code>onMeasure()</code> 方法，并在里面调用 <code>super.onMeasure()</code>，触发原有的自我测量；</li><li>在 <code>super.onMeasure()</code> 的下面用 <code>getMeasuredWidth()</code> 和 <code>getMeasuredHeight()</code> 来获取到之前的测量结果，并使用自己的算法，根据测量结果计算出新的结果；</li><li>调用 <code>setMeasuredDimension()</code> 来保存新的结果。</li></ol><h2 id="_2-全新定义view的尺寸" tabindex="-1"><a class="header-anchor" href="#_2-全新定义view的尺寸" aria-hidden="true">#</a> 2. 全新定义View的尺寸</h2><h3 id="全新定制尺寸和修改尺寸的最重要区别" tabindex="-1"><a class="header-anchor" href="#全新定制尺寸和修改尺寸的最重要区别" aria-hidden="true">#</a> 全新定制尺寸和修改尺寸的最重要区别</h3><p>需要在计算的同时，保证计算结果满足父 View 给出的的尺寸限制</p><h3 id="父-view-的尺寸限制" tabindex="-1"><a class="header-anchor" href="#父-view-的尺寸限制" aria-hidden="true">#</a> 父 View 的尺寸限制</h3><ol><li>由来：开发者的要求（布局文件中 <code>layout_</code> 打头的属性）经过父 View 处理计算后的更精确的要求；</li><li>限制的分类： <ol><li><code>UNSPECIFIED</code>：不限制</li><li><code>AT_MOST</code>：限制上限</li><li><code>EXACTLY</code>：限制固定值</li></ol></li></ol><h3 id="全新定义自定义view尺寸的方式" tabindex="-1"><a class="header-anchor" href="#全新定义自定义view尺寸的方式" aria-hidden="true">#</a> 全新定义自定义View尺寸的方式</h3><ol><li>重新 <code>onMeasure()</code>，并计算出 View 的尺寸；</li><li>使用 <code>resolveSize()</code> 来让子 View 的计算结果符合父 View 的限制（当然，如果你想用自己的方式来满足父 View 的限制也行）。</li></ol><h2 id="_3-自定义定制-layout-的内部布局" tabindex="-1"><a class="header-anchor" href="#_3-自定义定制-layout-的内部布局" aria-hidden="true">#</a> 3. 自定义定制 Layout 的内部布局</h2><h3 id="定制-layout-内部布局的方式" tabindex="-1"><a class="header-anchor" href="#定制-layout-内部布局的方式" aria-hidden="true">#</a> 定制 Layout 内部布局的方式</h3><ol><li>重写 <code>onMeasure()</code> 来计算内部布局</li><li>重写 <code>onLayout()</code> 来摆放子 View</li></ol><h3 id="重写-onmeasure-的三个步骤" tabindex="-1"><a class="header-anchor" href="#重写-onmeasure-的三个步骤" aria-hidden="true">#</a> 重写 onMeasure() 的三个步骤：</h3><ol><li>调用每个子 View 的 <code>measure()</code> 来计算子 View 的尺寸</li><li>计算子 View 的位置并保存子 View 的位置和尺寸</li><li>计算自己的尺寸并用 <code>setMeasuredDimension()</code> 保存</li></ol><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesimage-20250131213204572.png" alt="image-20250131213204572"></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesimage-20250131213324347.png" alt="image-20250131213324347"></p><h3 id="计算子-view-尺寸的关键" tabindex="-1"><a class="header-anchor" href="#计算子-view-尺寸的关键" aria-hidden="true">#</a> 计算子 View 尺寸的关键</h3><p>计算子 View 的尺寸，关键在于 <code>measure()</code> 方法的两个参数——也就是子 View 的两个 <code>MeasureSpec</code> 的计算。</p><h4 id="子-view-的-measurespec-的计算方式" tabindex="-1"><a class="header-anchor" href="#子-view-的-measurespec-的计算方式" aria-hidden="true">#</a> 子 View 的 MeasureSpec 的计算方式：</h4><ul><li>结合开发者的要求（xml 中 <code>layout_</code> 打头的属性）和自己的可用空间（自己的尺寸上限 - 已用尺寸）</li><li>尺寸上限根据自己的 <code>MeasureSpec</code> 中的 mode 而定 <ul><li>EXACTLY / AT_MOST：尺寸上限为 <code>MeasureSpec</code> 中的 <code>size</code></li><li>UNSPECIFIED：尺寸无上限</li></ul></li></ul><h3 id="重写-onlayout-的方式" tabindex="-1"><a class="header-anchor" href="#重写-onlayout-的方式" aria-hidden="true">#</a> 重写 onLayout() 的方式</h3><p>在 <code>onLayout()</code> 里调用每个子 View 的 <code>layout()</code> ，让它们保存自己的位置和尺寸。</p>',38),u={href:"https://rengwuxian.com/ui-2-1/",target:"_blank",rel:"noopener noreferrer"};function h(w,p){const i=d("ExternalLinkIcon");return c(),r("div",null,[s,o("p",null,[e("本文转自 "),o("a",u,[e("https://rengwuxian.com/ui-2-1/"),n(i)]),e("，如有侵权，请联系删除。")])])}const g=a(t,[["render",h],["__file","zidingyiView2-1-bujujichu.html.vue"]]);export{g as default};
