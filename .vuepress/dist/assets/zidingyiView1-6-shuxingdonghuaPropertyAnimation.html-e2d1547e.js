import{_ as t,r as s,o,c as i,b as a,d as n,e as c,a as p}from"./app-e8f85126.js";const r={},l=p(`<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>Android 里动画是有一些分类的：动画可以分为两类：Animation 和 Transition；其中 Animation 又可以再分为 View Animation 和 Property Animation 两类： View Animation 是纯粹基于 framework 的绘制转变，比较简单，如果你有兴趣的话可以上网搜一下它的用法；Property Animation，属性动画，这是在 Android 3.0 开始引入的新的动画形式，不过说它新只是相对的，它已经有好几年的历史了，而且现在的项目中的动画 99% 都是用的它，极少再用到 View Animation 了。属性动画不仅可以使用自带的 API 来实现最常用的动画，而且通过自定义 View 的方式来做出定制化的动画。除了这两种 Animation，还有一类动画是 Transition。 Transition 这个词的本意是转换，在 Android 里指的是切换界面时的动画效果，这个在逻辑上要复杂一点，不过它的重点是在于切换而不是动画，所以它也不是这次要讨论的内容。这次的内容只专注于一点：</p><p>Property Animation（属性动画）。在这一期我就基于前面几期讲过的自定义绘制，这一个自定义 View 的分支，来说一下属性动画的原理以及使用。</p><h2 id="viewpropertyanimator" tabindex="-1"><a class="header-anchor" href="#viewpropertyanimator" aria-hidden="true">#</a> ViewPropertyAnimator</h2><p>使用方式：<code>View.animate()</code> 后跟 <code>translationX()</code> 等方法，动画会自动执行。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>view<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">translationX</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj7xlvu1rgg30le0con5e.gif" alt=""></p><p>具体可以跟的方法以及方法所对应的 <code>View</code> 中的实际操作的方法如下图所示：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj7x3rm1xxj30u50laq6y.jpg" alt=""></p><p>从图中可以看到， <code>View</code> 的每个方法都对应了 <code>ViewPropertyAnimator</code> 的两个方法，其中一个是带有 <code>-By</code> 后缀的，例如，<code>View.setTranslationX()</code> 对应了 <code>ViewPropertyAnimator.translationX()</code> 和 <code>ViewPropertyAnimator.translationXBy()</code> 这两个方法。其中带有 <code>-By()</code> 后缀的是增量版本的方法，例如，<code>translationX(100)</code> 表示用动画把 <code>View</code> 的 <code>translationX</code> 值渐变为 <code>100</code>，而 <code>translationXBy(100)</code> 则表示用动画把 <code>View</code> 的 <code>translationX</code> 值渐变地增加 <code>100</code>。l</p><p>这些方法的效果都简单易懂，而且视频里也有简单的演示，所以就不放示例图了。如果你想看，可以去下面的练习项目。（最好顺便也练一下代码）</p><h2 id="objectanimator" tabindex="-1"><a class="header-anchor" href="#objectanimator" aria-hidden="true">#</a> ObjectAnimator</h2><p>使用方式：</p><ol><li>如果是自定义控件，需要添加 <code>setter</code> / <code>getter</code> 方法；</li><li>用 <code>ObjectAnimator.ofXXX()</code> 创建 <code>ObjectAnimator</code> 对象；</li><li>用 <code>start()</code> 方法执行动画。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SportsView</span> <span class="token keyword">extends</span> <span class="token class-name">View</span> <span class="token punctuation">{</span>
\u2028    <span class="token keyword">float</span> progress <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment">// 创建 getter 方法</span>
    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> progress<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 创建 setter 方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setProgress</span><span class="token punctuation">(</span><span class="token keyword">float</span> progress<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>progress <span class="token operator">=</span> progress<span class="token punctuation">;</span>
        <span class="token function">invalidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDraw</span><span class="token punctuation">(</span><span class="token class-name">Canvas</span> canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onDraw</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

        canvas<span class="token punctuation">.</span><span class="token function">drawArc</span><span class="token punctuation">(</span>arcRectF<span class="token punctuation">,</span> <span class="token number">135</span><span class="token punctuation">,</span> progress <span class="token operator">*</span> <span class="token number">2.7f</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> paint<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token comment">// 创建 ObjectAnimator 对象</span>
<span class="token class-name">ObjectAnimator</span> animator <span class="token operator">=</span> <span class="token class-name">ObjectAnimator</span><span class="token punctuation">.</span><span class="token function">ofFloat</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> <span class="token string">&quot;progress&quot;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 执行动画</span>
animator<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj7y2vnw5jg30ek0dijwq.gif" alt=""></p><h2 id="通用功能" tabindex="-1"><a class="header-anchor" href="#通用功能" aria-hidden="true">#</a> 通用功能</h2><h3 id="setduration-int-duration-设置动画时长" tabindex="-1"><a class="header-anchor" href="#setduration-int-duration-设置动画时长" aria-hidden="true">#</a> setDuration(int duration) 设置动画时长</h3><p>单位是毫秒。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// imageView1: 500 毫秒</span>
imageView1<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">translationX</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">setDuration</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// imageView2: 2 秒</span>
<span class="token class-name">ObjectAnimator</span> animator <span class="token operator">=</span> <span class="token class-name">ObjectAnimator</span><span class="token punctuation">.</span><span class="token function">ofFloat</span><span class="token punctuation">(</span>
        imageView2<span class="token punctuation">,</span> <span class="token string">&quot;translationX&quot;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
animator<span class="token punctuation">.</span><span class="token function">setDuration</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
animator<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj7yc68dgrg30le0miken.gif" alt=""></p><h3 id="setinterpolator-interpolator-interpolator-设置-interpolator" tabindex="-1"><a class="header-anchor" href="#setinterpolator-interpolator-interpolator-设置-interpolator" aria-hidden="true">#</a> setInterpolator(Interpolator interpolator) 设置 Interpolator</h3><p>视频里已经说了， <code>Interpolator</code> 其实就是速度设置器。你在参数里填入不同的 <code>Interpolator</code> ，动画就会以不同的速度模型来执行。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// imageView1: 线性 Interpolator，匀速</span>
imageView1<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">translationX</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">setInterpolator</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinearInterpolator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// imageView: 带施法前摇和回弹的 Interpolator</span>
<span class="token class-name">ObjectAnimator</span> animator <span class="token operator">=</span> <span class="token class-name">ObjectAnimator</span><span class="token punctuation">.</span><span class="token function">ofFloat</span><span class="token punctuation">(</span>
        imageView2<span class="token punctuation">,</span> <span class="token string">&quot;translationX&quot;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
animator<span class="token punctuation">.</span><span class="token function">setInterpolator</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AnticipateOvershootInterpolator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
animator<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8ffqb46bg30lg0buduv.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8fg48mu1g30lg0bunfi.gif" alt=""></p><p>简单介绍一下每一个 <code>Interpolator</code>。</p><h4 id="acceleratedecelerateinterpolator" tabindex="-1"><a class="header-anchor" href="#acceleratedecelerateinterpolator" aria-hidden="true">#</a> AccelerateDecelerateInterpolator</h4><p>先加速再减速。这是默认的 <code>Interpolator</code>，也就是说如果你不设置的话，那么动画将会使用这个 <code>Interpolator</code>。</p><p>视频里已经说过了，这个是一种最符合现实中物体运动的 <code>Interpolator</code>，它的动画效果<strong>看起来就像是物体从速度为 0 开始逐渐加速，然后再逐渐减速直到 0 的运动</strong>。它的速度 / 时间曲线以及动画完成度 / 时间曲线都是一条正弦 / 余弦曲线（这句话看完就忘掉就行，没用）。具体的效果如下：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8haplmxvg30lg0bu4eu.gif" alt=""></p><blockquote><p>好像不太看得出来加速减速过程？你就将就着看吧，毕竟 gif 不是视频，要啥自行车啊。</p></blockquote><p><strong>用途</strong>：就像上面说的，它是一种最符合物理世界的模型，所以如果你要做的是最简单的状态变化（位移、放缩、旋转等等），那么一般不用设置 <code>Interpolator</code>，就用这个默认的最好。</p><h4 id="linearinterpolator" tabindex="-1"><a class="header-anchor" href="#linearinterpolator" aria-hidden="true">#</a> LinearInterpolator</h4><p>匀速。</p><p>匀速就不用解释了吧？直接上效果：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8ffqb46bg30lg0buduv.gif" alt=""></p><h4 id="accelerateinterpolator" tabindex="-1"><a class="header-anchor" href="#accelerateinterpolator" aria-hidden="true">#</a> AccelerateInterpolator</h4><p>持续加速。</p><p>在整个动画过程中，一直在加速，直到动画结束的一瞬间，直接停止。</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8hj03zvog30lg0bu4e0.gif" alt=""></p><p>别看见它加速骤停就觉得这是个神经病模型哦，它很有用的。它主要用在离场效果中，比如某个物体从界面中飞离，就可以用这种效果。它给人的感觉就会是「这货从零起步，加速飞走了」。到了最后动画骤停的时候，物体已经飞出用户视野，看不到了，所以他们是并不会察觉到这个骤停的。</p><h4 id="decelerateinterpolator" tabindex="-1"><a class="header-anchor" href="#decelerateinterpolator" aria-hidden="true">#</a> DecelerateInterpolator</h4><p>持续减速直到 0。</p><p>动画开始的时候是最高速度，然后在动画过程中逐渐减速，直到动画结束的时候恰好减速到 0。</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8hs2sgltg30lg0bunbv.gif" alt=""></p><p>它的效果和上面这个 <code>AccelerateInterpolator</code> 相反，适用场景也和它相反：它主要用于入场效果，比如某个物体从界面的外部飞入界面后停在某处。它给人的感觉会是「咦飞进来个东西，让我仔细看看，哦原来是 XXX」。</p><h4 id="anticipateinterpolator" tabindex="-1"><a class="header-anchor" href="#anticipateinterpolator" aria-hidden="true">#</a> AnticipateInterpolator</h4><p>先回拉一下再进行正常动画轨迹。效果看起来有点像投掷物体或跳跃等动作前的蓄力。</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8hwknr1rg30lg0buaqt.gif" alt=""></p><p>如果是图中这样的平移动画，那么就是位置上的回拉；如果是放大动画，那么就是先缩小一下再放大；其他类型的动画同理。</p><p>这个 <code>Interpolator</code> 就有点耍花样了。没有通用的适用场景，根据具体需求和设计师的偏好而定。</p><h4 id="overshootinterpolator" tabindex="-1"><a class="header-anchor" href="#overshootinterpolator" aria-hidden="true">#</a> OvershootInterpolator</h4><p>动画会超过目标值一些，然后再弹回来。效果看起来有点像你一屁股坐在沙发上后又被弹起来一点的感觉。</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8i6bnopfg30lg0buwte.gif" alt=""></p><p>和 <code>AnticipateInterpolator</code> 一样，这是个耍花样的 <code>Interpolator</code>，没有通用的适用场景。</p><h4 id="anticipateovershootinterpolator" tabindex="-1"><a class="header-anchor" href="#anticipateovershootinterpolator" aria-hidden="true">#</a> AnticipateOvershootInterpolator</h4><p>上面这两个的结合版：开始前回拉，最后超过一些然后回弹。</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8i97q2e1g30lg0bunfi.gif" alt=""></p><p>依然耍花样，不多解释。</p><h4 id="bounceinterpolator" tabindex="-1"><a class="header-anchor" href="#bounceinterpolator" aria-hidden="true">#</a> BounceInterpolator</h4><p>在目标值处弹跳。有点像玻璃球掉在地板上的效果。</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8ia6zyl1g30lg0butmb.gif" alt=""></p><p>耍花样 +1。</p><h4 id="cycleinterpolator" tabindex="-1"><a class="header-anchor" href="#cycleinterpolator" aria-hidden="true">#</a> CycleInterpolator</h4><p>这个也是一个正弦 / 余弦曲线，不过它和 <code>AccelerateDecelerateInterpolator</code> 的区别是，它可以自定义曲线的周期，所以动画可以不到终点就结束，也可以到达终点后回弹，回弹的次数由曲线的周期决定，曲线的周期由 <code>CycleInterpolator()</code> 构造方法的参数决定。</p><blockquote><p>参数为 0.5f：</p></blockquote><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8in23hktg30lg0bu197.gif" alt=""></p><blockquote><p>参数为 2f：</p></blockquote><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8iuqytg8g30lg0buqoh.gif" alt=""></p><h4 id="pathinterpolator" tabindex="-1"><a class="header-anchor" href="#pathinterpolator" aria-hidden="true">#</a> PathInterpolator</h4><p>自定义动画完成度 / 时间完成度曲线。</p><p>用这个 <code>Interpolator</code> 你可以定制出任何你想要的速度模型。定制的方式是使用一个 <code>Path</code> 对象来绘制出你要的动画完成度 / 时间完成度曲线。例如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Path interpolatorPath = new Path();

...

// 匀速
interpolatorPath.lineTo(1, 1);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8jc60j9tj30cn09hq32.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8ffqb46bg30lg0buduv.gif" alt=""></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Path interpolatorPath = new Path();

...

// 先以「动画完成度 : 时间完成度 = 1 : 1」的速度匀速运行 25%
interpolatorPath.lineTo(0.25f, 0.25f);
// 然后瞬间跳跃到 150% 的动画完成度
interpolatorPath.moveTo(0.25f, 1.5f);
// 再匀速倒车，返回到目标点
interpolatorPath.lineTo(1, 1);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8jmom7kaj30cd0ay74f.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8jsmxr3eg30lg0buto5.gif" alt=""></p><p>你根据需求，绘制出自己需要的 <code>Path</code>，就能定制出你要的速度模型。</p><p>不过要注意，这条 <code>Path</code> 描述的其实是一个 <code>y = f(x) (0 ≤ x ≤ 1)</code> （y 为动画完成度，x 为时间完成度）的曲线，所以同一段时间完成度上不能有两段不同的动画完成度（这个好理解吧？因为内容不能出现分身术呀），而且每一个时间完成度的点上都必须要有对应的动画完成度（因为内容不能在某段时间段内消失呀）。所以，下面这样的 <code>Path</code> 是非法的，会导致程序 FC：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8lidbk4gj30c909jq34.jpg" alt=""></p><blockquote><p>出现重复的动画完成度，即动画内容出现「分身」——程序 FC</p></blockquote><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcly1fj8lk0do93j30c109baa6.jpg" alt=""></p><blockquote><p>有一段时间完成度没有对应的动画完成度，即动画出现「中断」——程序 FC</p></blockquote><p>除了上面的这些，Android 5.0 （API 21）引入了三个新的 <code>Interpolator</code> 模型，并把它们加入了 support v4 包中。这三个新的 <code>Interpolator</code> 每个都和之前的某个已有的 <code>Interpolator</code> 规则相似，只有略微的区别。</p><h4 id="fastoutlinearininterpolator" tabindex="-1"><a class="header-anchor" href="#fastoutlinearininterpolator" aria-hidden="true">#</a> FastOutLinearInInterpolator</h4><p>加速运动。</p><p>这个 <code>Interpolator</code> 的作用你不能看它的名字，一会儿 fast 一会儿 linear 的，完全看不懂。其实它和 <code>AccelerateInterpolator</code> 一样，都是一个持续加速的运动路线。只不过 <code>FastOutLinearInInterpolator</code> 的曲线公式是用的贝塞尔曲线，而 <code>AccelerateInterpolator</code> 用的是指数曲线。具体来说，它俩最主要的区别是 <code>FastOutLinearInInterpolator</code> 的初始阶段加速度比 <code>AccelerateInterpolator</code> 要快一些。</p><p><code>FastOutLinearInInterpolator</code>：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8n3lpf5vj30bs08v74f.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8n3z1vlsg30lg0bunfp.gif" alt=""></p><p><code>AccelerateInterpolator</code>：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8n5nersij30ci09eglr.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8n5549ycg30lg0bu4e0.gif" alt=""></p><p>能看出它俩的区别吗？</p><p>能看出来就怪了。这俩的速度模型几乎就是一样的，不信我把它们的动画完成度 / 时间完成度曲线放在一起给你看：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8nao9l37j30c709e3yo.jpg" alt=""></p><p>看到了吗？两条线几乎是一致的，只是红线比绿线更早地到达了较高的斜率，这说明在初始阶段，<code>FastOutLinearInInterpolator</code> 的加速度比 <code>AccelerateInterpolator</code> 更高。</p><p>那么这意味着什么呢？</p><p>意味个毛。实际上，这点区别，在实际应用中用户根本察觉不出来。而且，<code>AccelerateInterpolator</code> 还可以在构造方法中调节变速系数，分分钟调节到和 <code>FastOutLinearInInterpolator</code> （几乎）一模一样。所以你在使用加速模型的时候，这两个选哪个都一样，没区别的。</p><p>那么既然都一样，我做这么多对比，讲这么些干什么呢？</p><p>因为我得让你了解。它俩虽然「用起来没区别」，但这是基于我对它足够了解所做出的判断，可我如果直接甩给你一句「它俩没区别，想用谁用谁，少废话别问那么多」，你心里肯定会有一大堆疑问，在开发时用到它们的时候也会畏畏缩缩心里打鼓的，对吧？</p><h4 id="fastoutslowininterpolator" tabindex="-1"><a class="header-anchor" href="#fastoutslowininterpolator" aria-hidden="true">#</a> FastOutSlowInInterpolator</h4><p>先加速再减速。</p><p>同样也是先加速再减速的还有前面说过的 <code>AccelerateDecelerateInterpolator</code>，不过它们的效果是明显不一样的。<code>FastOutSlowInInterpolator</code> 用的是贝塞尔曲线，<code>AccelerateDecelerateInterpolator</code> 用的是正弦 / 余弦曲线。具体来讲， <code>FastOutSlowInInterpolator</code> 的前期加速度要<strong>快得多</strong>。</p><p><code>FastOutSlowInInterpolator</code>：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8ojcnakkj30ca094q32.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8ojvxe6dg30lg0bu17c.gif" alt=""></p><p><code>AccelerateDecelerateInterpolator</code>：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8okq3druj30c7092jrj.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8ol1bvc3g30lg0bu4eu.gif" alt=""></p><p>不论是从动图还是从曲线都可以看出，这二者比起来，<code>FastOutSlowInInterpolator</code> 的前期加速更猛一些，后期的减速过程的也减得更迅速。用更直观一点的表达就是，<code>AccelerateDecelerateInterpolator</code> 像是物体的自我移动，而 <code>FastOutSlowInInterpolator</code> 则看起来像有一股强大的外力「推」着它加速，在接近目标值之后又「拽」着它减速。总之，<code>FastOutSlowInterpolator</code> 看起来有一点「着急」的感觉。</p><p>二者曲线对比图：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8pcob93jj30bc08fmxb.jpg" alt=""></p><h4 id="linearoutslowininterpolator" tabindex="-1"><a class="header-anchor" href="#linearoutslowininterpolator" aria-hidden="true">#</a> LinearOutSlowInInterpolator</h4><p>持续减速。</p><p>它和 <code>DecelerateInterpolator</code> 比起来，同为减速曲线，主要区别在于 <code>LinearOutSlowInInterpolator</code> 的初始速度更高。对于人眼的实际感觉，区别其实也不大，不过还是能看出来一些的。</p><p><code>LinearOutSlowInInterpolator</code>：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8po2x425j30cf098mxa.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8plj835gg30lg0bu4dl.gif" alt=""></p><p><code>DecelerateInterpolator</code>：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8pntgmfuj30ca09874f.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8pof5h5dg30lg0bunbv.gif" alt=""></p><p>二者曲线对比：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images006tKfTcgy1fj8ppbuqoaj30cg093jrk.jpg" alt=""></p><p>对于所有 <code>Interpolator</code> 的介绍就到这里。这些 <code>Interpolator</code>，有的较为常用且有通用的使用场景，有的需要你自己来根据情况而定。把它们了解清楚了，对于制作出观感舒服的动画很有好处。</p><h3 id="设置监听器" tabindex="-1"><a class="header-anchor" href="#设置监听器" aria-hidden="true">#</a> 设置监听器</h3><p>给动画设置监听器，可以在关键时刻得到反馈，从而及时做出合适的操作，例如在动画的属性更新时同步更新其他数据，或者在动画结束后回收资源等。</p><p>设置监听器的方法， <code>ViewPropertyAnimator</code> 和 <code>ObjectAnimator</code> 略微不一样： <code>ViewPropertyAnimator</code> 用的是 <code>setListener()</code> 和 <code>setUpdateListener()</code> 方法，可以设置一个监听器，要移除监听器时通过 <code>set[Update]Listener(null)</code> 填 null 值来移除；而 <code>ObjectAnimator</code> 则是用 <code>addListener()</code> 和 <code>addUpdateListener()</code> 来添加一个或多个监听器，移除监听器则是通过 <code>remove[Update]Listener()</code> 来指定移除对象。</p><p>另外，由于 <code>ObjectAnimator</code> 支持使用 <code>pause()</code> 方法暂停，所以它还多了一个 <code>addPauseListener()</code> / <code>removePauseListener()</code> 的支持；而 <code>ViewPropertyAnimator</code> 则独有 <code>withStartAction()</code> 和 <code>withEndAction()</code> 方法，可以设置一次性的动画开始或结束的监听。</p><h4 id="viewpropertyanimator-setlistener-objectanimator-addlistener" tabindex="-1"><a class="header-anchor" href="#viewpropertyanimator-setlistener-objectanimator-addlistener" aria-hidden="true">#</a> ViewPropertyAnimator.setListener() / ObjectAnimator.addListener()</h4><p>这两个方法的名称不一样，可以设置的监听器数量也不一样，但它们的参数类型都是 <code>AnimatorListener</code>，所以本质上其实都是一样的。 <code>AnimatorListener</code> 共有 4 个回调方法：</p><h5 id="onanimationstart-animator-animation" tabindex="-1"><a class="header-anchor" href="#onanimationstart-animator-animation" aria-hidden="true">#</a> onAnimationStart(Animator animation)</h5><p>当动画开始执行时，这个方法被调用。</p><h5 id="onanimationend-animator-animation" tabindex="-1"><a class="header-anchor" href="#onanimationend-animator-animation" aria-hidden="true">#</a> onAnimationEnd(Animator animation)</h5><p>当动画结束时，这个方法被调用。</p><h5 id="onanimationcancel-animator-animation" tabindex="-1"><a class="header-anchor" href="#onanimationcancel-animator-animation" aria-hidden="true">#</a> onAnimationCancel(Animator animation)</h5><p>当动画被通过 <code>cancel()</code> 方法取消时，这个方法被调用。</p><p>需要说明一下的是，就算动画被取消，<code>onAnimationEnd()</code> 也会被调用。所以当动画被取消时，如果设置了 <code>AnimatorListener</code>，那么 <code>onAnimationCancel()</code> 和 <code>onAnimationEnd()</code> 都会被调用。<code>onAnimationCancel()</code> 会先于 <code>onAnimationEnd()</code> 被调用。</p><h5 id="onanimationrepeat-animator-animation" tabindex="-1"><a class="header-anchor" href="#onanimationrepeat-animator-animation" aria-hidden="true">#</a> onAnimationRepeat(Animator animation)</h5><p>当动画通过 <code>setRepeatMode()</code> / <code>setRepeatCount()</code> 或 <code>repeat()</code> 方法重复执行时，这个方法被调用。</p><p>由于 <code>ViewPropertyAnimator</code> 不支持重复，所以这个方法对 <code>ViewPropertyAnimator</code> 相当于无效。</p><h4 id="viewpropertyanimator-setupdatelistener-objectanimator-addupdatelistener" tabindex="-1"><a class="header-anchor" href="#viewpropertyanimator-setupdatelistener-objectanimator-addupdatelistener" aria-hidden="true">#</a> ViewPropertyAnimator.setUpdateListener() / ObjectAnimator.addUpdateListener()</h4><p>和上面的两个方法一样，这两个方法虽然名称和可设置的监听器数量不一样，但本质其实都一样的，它们的参数都是 <code>AnimatorUpdateListener</code>。它只有一个回调方法：<code>onAnimationUpdate(ValueAnimator animation)</code>。</p><h5 id="onanimationupdate-valueanimator-animation" tabindex="-1"><a class="header-anchor" href="#onanimationupdate-valueanimator-animation" aria-hidden="true">#</a> onAnimationUpdate(ValueAnimator animation)</h5><p>当动画的属性更新时（不严谨的说，即每过 10 毫秒，动画的完成度更新时），这个方法被调用。</p><p>方法的参数是一个 <code>ValueAnimator</code>，<code>ValueAnimator</code> 是 <code>ObjectAnimator</code> 的父类，也是 <code>ViewPropertyAnimator</code> 的内部实现，所以这个参数其实就是 <code>ViewPropertyAnimator</code> 内部的那个 <code>ValueAnimator</code>，或者对于 <code>ObjectAnimator</code> 来说就是它自己本身。</p><p><code>ValueAnimator</code> 有很多方法可以用，它可以查看当前的动画完成度、当前的属性值等等。不过 <code>ValueAnimator</code> 是下一期才讲的内容，所以这期就不多说了。</p><h4 id="objectanimator-addpauselistener" tabindex="-1"><a class="header-anchor" href="#objectanimator-addpauselistener" aria-hidden="true">#</a> ObjectAnimator.addPauseListener()</h4><p>由于 <code>ObjectAnimator.pause()</code> 是下期的内容，所以这个方法在这期就不讲了。当然，如果你有兴趣的话，现在就了解一下也可以。</p><h4 id="viewpropertyanimator-withstartaction-endaction" tabindex="-1"><a class="header-anchor" href="#viewpropertyanimator-withstartaction-endaction" aria-hidden="true">#</a> ViewPropertyAnimator.withStartAction/EndAction()</h4><p>这两个方法是 <code>ViewPropertyAnimator</code> 的独有方法。它们和 <code>set/addListener()</code> 中回调的 <code>onAnimationStart()</code> / <code>onAnimationEnd()</code> 相比起来的不同主要有两点：</p><ol><li><code>withStartAction()</code> / <code>withEndAction()</code> 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用 <code>ViewPropertyAnimator</code> 来做别的动画，用它们设置的回调也不会再被调用。而 <code>set/addListener()</code> 所设置的 <code>AnimatorListener</code> 是持续有效的，当动画重复执行时，回调总会被调用。</li><li><code>withEndAction()</code> 设置的回调只有在动画正常结束时才会被调用，而在动画被取消时不会被执行。这点和 <code>AnimatorListener.onAnimationEnd()</code> 的行为是不一致的。</li></ol><p>关于监听器，就说到这里。本期内容的讲义部分也到此结束。</p>`,155),d={href:"https://rengwuxian.com/ui-1-6/",target:"_blank",rel:"noopener noreferrer"};function u(m,g){const e=s("ExternalLinkIcon");return o(),i("div",null,[l,a("p",null,[n("本文转自 "),a("a",d,[n("https://rengwuxian.com/ui-1-6/"),c(e)]),n("，如有侵权，请联系删除。")])])}const k=t(r,[["render",u],["__file","zidingyiView1-6-shuxingdonghuaPropertyAnimation.html.vue"]]);export{k as default};
