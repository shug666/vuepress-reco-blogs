import{_ as r,r as e,o as s,c as g,b as a,d as t,e as o,a as p}from"./app-ee4ba21e.js";const i={},h=p('<h2 id="java成员变量、局部变量" tabindex="-1"><a class="header-anchor" href="#java成员变量、局部变量" aria-hidden="true">#</a> Java成员变量、局部变量</h2><hr><hr><p><img src="https://raw.githubusercontent.com/shug666/image/main/images/20200512215157577.png" alt=""></p><p>1）静态变量只会初始化（执行）一次。</p><p>2）当有父类时，完整的初始化顺序为：父类静态变量（静态代码块）-&gt;子类静态变量（静态代码块）-&gt;父类非静态变量（非静态代码块）-&gt;父类构造器 -&gt;子类非静态变量（非静态代码块）-&gt;子类构造器 。</p><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h3><p><strong>成员变量在使用对象之前就加载好，而局部变量需要在类或对象调用方法时才会创建</strong>。</p><p>个人认为，这种分类方式有点粗糙，以下是比较详细的变量分类方式：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images/20200512211919973.png" alt=""></p><h3 id="成员变量" tabindex="-1"><a class="header-anchor" href="#成员变量" aria-hidden="true">#</a> 成员变量</h3><p><img src="https://raw.githubusercontent.com/shug666/image/main/images/20200512212055721.png" alt=""></p><p>在这里，成员变量分为类变量和实例变量。</p><p><strong>类变量是类加载过程中的准备阶段就已经分配内存了，直至类被销毁，类变量的内存才会释放</strong>。</p><p>而<strong>实例变量是在类的实例创建（创建对象）时存在直至实例被销毁</strong>。</p><p><strong>1 访问类变量</strong>的方式有两种：类.类变量、实例.类变量。<strong>除了类本身可以对类变量进行修改外，类的实例也会对类变量进行修改，且其他实例也会看到变化</strong>。</p><p><strong>2 访问实例变量</strong>的方式就只有一种：实例.实例变量。<strong>每个实例的实例变量都不对其他实例可见</strong>。</p><h3 id="局部变量" tabindex="-1"><a class="header-anchor" href="#局部变量" aria-hidden="true">#</a> 局部变量</h3><p><img src="https://raw.githubusercontent.com/shug666/image/main/images/20200512212340576.png" alt=""></p><p>局部变量在此分为形参、方法局部变量和代码块局部变量。</p><p><strong>1 形参是方法签名上的局部变量</strong>，当对象调用方法时传入了实参，但是传入方法的过程中会创建一个<strong>形参，作为值传递的副本</strong>。</p><p><strong>2 方法局部变量是在方法中创建变量</strong>。</p><p>3 而<strong>代码块局部变量，即类中定义好的代码块</strong>。</p><h3 id="六个变量的加载顺序如下" tabindex="-1"><a class="header-anchor" href="#六个变量的加载顺序如下" aria-hidden="true">#</a> 六个变量的加载顺序如下</h3><p>通过上述对变量的介绍，可以得到答案。先看主函数有没有创建对象，有创建对象的话看对应类中代码块有没有输出语句，然后返回主函数，依次执行语句和访问方法。可以看出，这六个变量的加载顺序如下</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images/20200512213055706.png" alt=""></p><h3 id="但是这六种变量为什么是这样的加载顺序" tabindex="-1"><a class="header-anchor" href="#但是这六种变量为什么是这样的加载顺序" aria-hidden="true">#</a> <strong>但是这六种变量为什么是这样的加载顺序？</strong></h3><p><strong>按虚拟机加载顺序划分变量类型</strong></p><p>我们用<strong>类加载-&gt;创建对象-&gt;调用方法</strong>的顺序来介绍变量的加载顺序。</p><p><strong>类加载</strong></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images/2020051221324312.png" alt=""></p><p><strong>创建对象</strong></p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images/20200512213320729.png" alt=""></p><p>而<strong>实例变量和实例代码块是在创建对象后，进行对象初始化的时候才加载到内存中</strong>。</p><p><strong>调用方法</strong></p><p>在调用有参函数的时候，虚拟机会将实参复制后，生成形参，实参和形参的值相同，但是内存地址不同，即<strong>形参相对于实参来说，只是另一个有着同样的值的变量</strong>。</p><p>所以在有参函数调用的过程中，<strong>形参先于方法局部变量被加载</strong>。</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images/20200512213428540.png" alt=""></p><h3 id="创建位置" tabindex="-1"><a class="header-anchor" href="#创建位置" aria-hidden="true">#</a> 创建位置</h3><p>方法区：类信息、类变量（静态变量和常量）、方法</p><p>堆：对象、成员变量</p><p>栈：局部变量</p><p>（1）当程序运行时，首先通过类装载器加载字节码文件，经过解析后装入方法区！在方法区中存了类的各种信息，包括类变量、常量及方法。对于同一个方法的调用，同一个类的不同实例调用的都是存在方法区的同一个方法。类变量的生命周期从程序开始运行时创建，到程序终止运行时结束！</p><p>（2）当程序中new一个对象时，这个对象存在堆中，对象的变量存在栈中，指向堆中的引用！对象的成员变量都存在堆中，当对象被回收时，对象的成员变量随之消失！</p><p>（3）当方法调用时，JVM会在栈中分配一个栈桢，存储方法的局部变量。当方法调用结束时，局部变量消失！</p>',45),c={href:"https://www.codenong.com/cs106085393/",target:"_blank",rel:"noopener noreferrer"};function m(d,u){const n=e("ExternalLinkIcon");return s(),g("div",null,[h,a("p",null,[t("本文转自 "),a("a",c,[t("https://www.codenong.com/cs106085393/"),o(n)]),t("，如有侵权，请联系删除。")])])}const b=r(i,[["render",m],["__file","Java-chengyuanbianliang-jububianliang.html.vue"]]);export{b as default};
