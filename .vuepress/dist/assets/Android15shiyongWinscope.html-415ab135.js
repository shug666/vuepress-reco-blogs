import{_ as t,r,o as p,c as o,b as e,d as a,e as s,a as i}from"./app-e8f85126.js";const c={},d={href:"https://source.android.google.cn/docs/core/graphics/tracing-win-transitions?hl=zh-cn#analyze-traces",target:"_blank",rel:"noopener noreferrer"},l=i(`<p>Winscope 是一款 Web 工具，可以让用户在动画和转换期间和之后记录、重放和分析多个系统服务的状态。Winscope 将所有相关的系统服务状态记录在一个跟踪文件中。使用带有跟踪文件的 Winscope 界面，您可以通过重放、单步执行和调试转换来针对每个动画帧检查这些服务的状态（无论是否有屏幕录制）。</p><p>说的通俗一点，我感觉Winscope就是在一段时间内的每一帧，都dump一下手机中的某些信息，然后将这些信息收集起来并且以图形的方式展示，如：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images202ee6eae72248c9862822e71655c992.png" alt="在这里插入图片描述"></p><p>本文主要记录一下我本地在Android15平台上使用Winscope的情况，这个跟个人使用的平台以及环境都有很大的关系，不一定说按照我的做法就一定成功，我遇到的问题你可能没有遇到，同样你遇到的问题我可能没有遇到。</p><h2 id="android15以前使用winscope" tabindex="-1"><a class="header-anchor" href="#android15以前使用winscope" aria-hidden="true">#</a> Android15以前使用Winscope</h2><p>1、在开发者模式中，“Quick settings developer tiles“中，开启”Winscope trace“：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesee9f139c227644f1bf22888d1d6f0196.png" alt="在这里插入图片描述"></p><p>2、执行复现问题的操作。</p><p>3、操作完后的winscope文件在手机保存到了<code>data/misc/wmtrace</code>，我们一般关注比较多的是保存了SurfaceFlinger的信息，“layers_trace.winscope”文件：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesc73bc943dc1c461680b42a68c72a7513.png" alt="在这里插入图片描述"></p><p>4、使用<code>prebuilts/misc/common/winscope/winscope.html</code>查看相关信息：</p><h3 id="通过-adb-命令捕获surfaceflinger跟踪记录" tabindex="-1"><a class="header-anchor" href="#通过-adb-命令捕获surfaceflinger跟踪记录" aria-hidden="true">#</a> 通过 adb 命令捕获SurfaceFlinger跟踪记录</h3><p>要记录 SurfaceFlinger 的跟踪情况，请执行以下操作：<br> 1、启用跟踪：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>adb shell <span class="token function">su</span> root <span class="token function">service</span> call SurfaceFlinger <span class="token number">1025</span> i32 <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、停用跟踪：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>adb shell <span class="token function">su</span> root <span class="token function">service</span> call SurfaceFlinger <span class="token number">1025</span> i32 <span class="token number">0</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>3、获取跟踪文件：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>adb pull /data/misc/wmtrace/layers_trace.winscope layers_trace.winscope
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>4、拖动到Winscope来查看layers_trace.winscope文件：</p><p>这里展示一下从Launcher启动google Files的过程。</p><h2 id="android15变动" tabindex="-1"><a class="header-anchor" href="#android15变动" aria-hidden="true">#</a> Android15变动</h2><p>然而这些在Android15上已经行不通了，如果我们使用adb命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>adb shell <span class="token function">su</span> root <span class="token function">service</span> call SurfaceFlinger <span class="token number">1025</span> i32 <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>去抓取跟踪信息，会报错：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Result: Parcel<span class="token punctuation">(</span>Error: 0xfffffffffffffffe <span class="token string">&quot;No such file or directory&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>原因则是Android15中SurfaceFlinger这块的逻辑已经被移除了：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesee8df13e1e1f4ccea93feb913d25c905.png" alt="在这里插入图片描述"></p><p>提示需要使用perfetto来开启layer追踪。</p><p>再根据google的官网介绍：</p>`,29),u={href:"https://source.android.google.cn/docs/core/graphics/tracing-win-transitions?hl=zh-cn#capture-traces-winscope",target:"_blank",rel:"noopener noreferrer"},g=e("p",null,"最新的情况是“Quick settings developer tiles“下移除了”Winscope trace“，移动到了“System Tracing”中：",-1),m=e("p",null,"如我的手机截图：",-1),h=e("p",null,[e("img",{src:"https://raw.githubusercontent.com/shug666/image/main/imagesa7bd15fcd2794078b33bf5d2b0558b9b.png",alt:"在这里插入图片描述"})],-1),b=e("p",null,"那现在的Android15要如何使用Winscope工具呢，毕竟这个工具还挺好用的。",-1),v=e("h2",{id:"android15使用winscope",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#android15使用winscope","aria-hidden":"true"},"#"),a(" Android15使用winscope")],-1),f=e("p",null,"首先根据google官网的指导去调试肯定是没错的，但是官网有些地方说的并不清楚，实际上去操作也遇到过很多问题，本文也参考了：",-1),_={href:"https://blog.csdn.net/learnframework/article/details/141681248",target:"_blank",rel:"noopener noreferrer"},k=i(`<p>另外我工作用的机器是windows+WSL，用的代码下载在了服务器，然后挂载到本地来查看的，实际操作起来一堆问题，虽然最后还是在本地弄好了，但这个是后话了。</p><p>最开始，为了实验一下按照官方的教程是否能够成功，我用的是公司机房的电脑，ubuntu系统，并且能够连接外网，先体验一下简单难度，再挑战地狱难度。</p><h3 id="_1-下载android15源码" tabindex="-1"><a class="header-anchor" href="#_1-下载android15源码" aria-hidden="true">#</a> 1. 下载Android15源码</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>repo init <span class="token parameter variable">-u</span> https://android.googlesource.com/platform/manifest <span class="token parameter variable">-b</span> android-15.0.0_r1
<span class="token comment">#清华镜像源 repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-15.0.0_r1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里只需要下载几个依赖的库就好了：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>repo <span class="token function">sync</span> development external/protobuf external/perfetto frameworks/base frameworks/libs/systemui frameworks/native frameworks/proto_logging platform_testing prebuilts/misc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>不同的Android版本不一样，具体是哪些库应该要看“development/tools/winscope/protos/build.js”的具体内容。</p><h3 id="_2-导航到-winscope-文件夹" tabindex="-1"><a class="header-anchor" href="#_2-导航到-winscope-文件夹" aria-hidden="true">#</a> 2. 导航到 Winscope 文件夹</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> development/tools/winscope
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_3-安装npm" tabindex="-1"><a class="header-anchor" href="#_3-安装npm" aria-hidden="true">#</a> 3. 安装npm</h3><p>查看版本号为：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ukynho@user:~$ <span class="token function">node</span> <span class="token parameter variable">-v</span>
v22.9.0
ukynho@user:~$ <span class="token function">npm</span> <span class="token parameter variable">-v</span>
<span class="token number">10.8</span>.3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用”apt-get“安装npm，我本地安装的node版本是10.19.0，低版本的node到后续的步骤可能会出错。</p><p>另外我这边查看node版本的时候，也遇到了GLIBC版本过低的错误，这一点更新到后面的解决问题的章节。</p><h3 id="_4-安装依赖项" tabindex="-1"><a class="header-anchor" href="#_4-安装依赖项" aria-hidden="true">#</a> 4. 安装依赖项</h3><p>使用以下命令安装依赖项：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如需查看可用命令的列表，请运行以下命令： <code>npm run</code></p><p>通过npm run命令查看的应该是package.json下的命令，我们重点关注build的这几个，“build:trace_processor”、“build:prod”&quot;和&quot;build:protos：</p><h3 id="_5-构建所有生产和测试目标" tabindex="-1"><a class="header-anchor" href="#_5-构建所有生产和测试目标" aria-hidden="true">#</a> 5. 构建所有生产和测试目标</h3><p>使用以下命令构建所有生产和测试目标：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> run build:prod
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实际上执行的也就是：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token function">npm</span> run build:trace_processor <span class="token operator">&amp;&amp;</span> <span class="token function">npm</span> run build:protos <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> dist/prod/ <span class="token operator">&amp;&amp;</span> webpack <span class="token parameter variable">--config</span> webpack.config.prod.js <span class="token parameter variable">--progress</span> <span class="token operator">&amp;&amp;</span> <span class="token function">cp</span> deps_build/trace_processor/to_be_served/* src/adb/winscope_proxy.py src/logo_light_mode.svg src/logo_dark_mode.svg src/viewers/components/rects/cube_full_shade.svg src/viewers/components/rects/cube_partial_shade.svg src/app/components/trackpad_right_click.svg src/app/components/trackpad_vertical_scroll.svg src/app/components/trackpad_horizontal_scroll.svg dist/prod/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我本地的情况是，当执行到以下步骤：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> winscope@0.0.0 build:protos /local/sdb/android-15/development/tools/winscope
<span class="token operator">&gt;</span> <span class="token function">node</span> protos/build.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>最终成功，显示：</p><p>webpack 5.91.0 compiled with 3 warnings in 35078ms</p><p>并生成<code>dist/prod</code>目录：</p><h3 id="_6-运行winscope" tabindex="-1"><a class="header-anchor" href="#_6-运行winscope" aria-hidden="true">#</a> 6. 运行Winscope</h3><p>使用以下命令运行 Winscope：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> run start
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后Winscope页面在浏览器中打开</p><h2 id="捕获追踪记录" tabindex="-1"><a class="header-anchor" href="#捕获追踪记录" aria-hidden="true">#</a> 捕获追踪记录</h2><h3 id="_1-在设备上捕获跟踪记录" tabindex="-1"><a class="header-anchor" href="#_1-在设备上捕获跟踪记录" aria-hidden="true">#</a> 1. 在设备上捕获跟踪记录</h3><p>这里是官网的介绍：</p><p>在针对动画问题提交错误时，在设备上捕获跟踪记录以收集数据。所有界面跟踪记录都是通过此方法记录的，因为无法自定义配置。</p><p>在 Android 设备上：</p>`,38),w={href:"https://developer.android.google.cn/studio/debug/dev-options?hl=zh-cn#enable",target:"_blank",rel:"noopener noreferrer"},x=i(`<p>2、选择<strong>开发者选项下的 System Tracing</strong>。</p><p>3、启用<strong>收集 Winscope 跟踪记录</strong>。</p><p>4、在<strong>其他</strong>下：</p><ol><li>启用<strong>在错误报告中附加录制内容</strong>。</li><li>启用<strong>显示“快捷设置”功能块</strong>。</li></ol><p>5、 导航到您需要重现错误的位置。</p><p>6、如需开始记录，请打开“快捷设置”，然后选择<strong>录制跟踪记录</strong>：</p><p><img src="https://i-blog.csdnimg.cn/direct/ec3de6c3cce54ad8ba23c916d2a969e2.png" alt="在这里插入图片描述"></p><p>7、仅执行重现错误所需的步骤。</p><p>8、如需停止捕获，请打开“快捷设置”，然后选择<strong>停止跟踪</strong>。</p><p>9、使用所列选项之一共享捕获的日志，如 Gmail、云端硬盘或 BetterBug。</p><p>我本地操作下来，看到最终的“perfetto-trace”文件是保存在了“data/local/traces”目录下，如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>data/local/traces/trace-MT6835-AP3A.240617.008-2024-10-15-10-33-52.perfetto-trace
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另外我没看到对应的视频，我个人觉得有“perfetto-trace”搭配视频就最好了，大部分情况下wm或者ime的信息啥的我不太需要，比如Transitions啥的一般看log就够了，当然特殊情况下肯定是有参考价值的。</p><h3 id="_2-通过-winscope-捕获跟踪记录" tabindex="-1"><a class="header-anchor" href="#_2-通过-winscope-捕获跟踪记录" aria-hidden="true">#</a> 2. 通过 Winscope 捕获跟踪记录</h3><p>这种方式虽然有点麻烦，但是能抓的信息却是最全，如果情况允许的，我最推荐这种。</p><p>1、执行以下命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>python3 development/tools/winscope/src/adb/winscope_proxy.py
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>生成了token：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images0881cb25524443d8aec117302e53e25b.png" alt="在这里插入图片描述"></p><p>2、在 <strong>Collect Traces</strong>（收集跟踪记录）界面上，点击 <strong>ADB Proxy</strong>（ADB 代理）：</p><p>输入token，然后点击“Connect”，选择对应的机器：</p><p>然后点击“Start trace”，就可以开始记录了。</p><p>最后你也可以把所有的文件下载下来查看，下载后是一个压缩包</p><p>另外说一下这个生成状态转储文件的功能：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images9108315608804f6e9d001c1924350e8d.png" alt="在这里插入图片描述"></p><p>我个人觉得也还不错，Android15上用“dumpsys SurfaceFlinger”看不到每一个Layer的具体信息了（也许还能看，我现在还没去研究），但是通过这里还是能看到：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images1644fb967fd1404dafadf53c9fd33247.png" alt="在这里插入图片描述"></p><h3 id="_3-通过-adb-命令捕获跟踪记录" tabindex="-1"><a class="header-anchor" href="#_3-通过-adb-命令捕获跟踪记录" aria-hidden="true">#</a> 3. 通过 adb 命令捕获跟踪记录</h3><p>这里重点看下SurfaceFlinger的部分，首先是官网的介绍。</p>`,29),S={href:"https://perfetto.dev/docs/concepts/config",target:"_blank",rel:"noopener noreferrer"},W=i(`<p>请参阅以下有关 SurfaceFlinger 层跟踪配置的示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>unique_session_name<span class="token operator">:</span> <span class="token string">&quot;surfaceflinger_layers_active&quot;</span>
buffers<span class="token operator">:</span> <span class="token punctuation">{</span>
    size_kb<span class="token operator">:</span> <span class="token number">63488</span>
    fill_policy<span class="token operator">:</span> <span class="token constant">RING_BUFFER</span>
<span class="token punctuation">}</span>
data_sources<span class="token operator">:</span> <span class="token punctuation">{</span>
    config <span class="token punctuation">{</span>
        name<span class="token operator">:</span> <span class="token string">&quot;android.surfaceflinger.layers&quot;</span>
        surfaceflinger_layers_config<span class="token operator">:</span> <span class="token punctuation">{</span>
            mode<span class="token operator">:</span> <span class="token constant">MODE_ACTIVE</span>
            trace_flags<span class="token operator">:</span> <span class="token constant">TRACE_FLAG_INPUT</span>
            trace_flags<span class="token operator">:</span> <span class="token constant">TRACE_FLAG_COMPOSITION</span>
            trace_flags<span class="token operator">:</span> <span class="token constant">TRACE_FLAG_HWC</span>
            trace_flags<span class="token operator">:</span> <span class="token constant">TRACE_FLAG_BUFFERS</span>
            trace_flags<span class="token operator">:</span> <span class="token constant">TRACE_FLAG_VIRTUAL_DISPLAYS</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请参阅以下示例命令，以生成 SurfaceFlinger 层的跟踪记录：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>adb shell <span class="token parameter variable">-t</span> perfetto <span class="token punctuation">\\</span>
    <span class="token parameter variable">-c</span> - <span class="token parameter variable">--txt</span> <span class="token punctuation">\\</span>
    <span class="token parameter variable">-o</span> /data/misc/perfetto-traces/trace <span class="token punctuation">\\</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我看了这个是比较懵逼的，最后参考了：</p>`,5),A={href:"https://perfetto.dev/docs/concepts/config",target:"_blank",rel:"noopener noreferrer"},y=i(`<p>才稍微弄懂了一点，主要是看关于Android的介绍：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images8aec5987a03044ff81583be619a74bae.png" alt="在这里插入图片描述"></p><p>接着是我本地的操作。</p><p>1、首先将以上配置写到一个文件中：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images4b170720778a46d5ac36af61f4e037de.png" alt="在这里插入图片描述"></p><p>命名为config.pbtx。</p><p>2、使用以下命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> config.pbtx <span class="token operator">|</span> adb shell perfetto <span class="token parameter variable">-c</span> - <span class="token parameter variable">--txt</span> <span class="token parameter variable">-o</span> /data/misc/perfetto-traces/test.perfetto-trace
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后在适当的时候断掉</p><p>最终在“/data/misc/perfetto-traces/”目录生成名为“test”的perfetto-trace文件：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images7ed4c5af0b914a91a8d4d17b7df87076.png" alt="在这里插入图片描述"></p><p>但是这里的生成的文件大小是0，所以肯定是哪里有点问题的，我现在还不清楚。</p><p>后续看了下perfetto官网的介绍，仿照着在配置文件中额外增加抓取时间，“duration_ms: 10000”，如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>duration_ms<span class="token operator">:</span> <span class="token number">10000</span>

unique_session_name<span class="token operator">:</span> <span class="token string">&quot;surfaceflinger_layers_active&quot;</span>
buffers<span class="token operator">:</span> <span class="token punctuation">{</span>
    size_kb<span class="token operator">:</span> <span class="token number">63488</span>
    fill_policy<span class="token operator">:</span> <span class="token constant">RING_BUFFER</span>
<span class="token punctuation">}</span>
data_sources<span class="token operator">:</span> <span class="token punctuation">{</span>
    config <span class="token punctuation">{</span>
        name<span class="token operator">:</span> <span class="token string">&quot;android.surfaceflinger.layers&quot;</span>
        surfaceflinger_layers_config<span class="token operator">:</span> <span class="token punctuation">{</span>
            mode<span class="token operator">:</span> <span class="token constant">MODE_ACTIVE</span>
            trace_flags<span class="token operator">:</span> <span class="token constant">TRACE_FLAG_INPUT</span>
            trace_flags<span class="token operator">:</span> <span class="token constant">TRACE_FLAG_COMPOSITION</span>
            trace_flags<span class="token operator">:</span> <span class="token constant">TRACE_FLAG_HWC</span>
            trace_flags<span class="token operator">:</span> <span class="token constant">TRACE_FLAG_BUFFERS</span>
            trace_flags<span class="token operator">:</span> <span class="token constant">TRACE_FLAG_VIRTUAL_DISPLAYS</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后果然就可以了</p><p>拖动到Winscope中可以查看：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images05b14b765bb1410a9f6f765634b6f9bb.png" alt="在这里插入图片描述"></p><p>3、最后如perfetto官网介绍的，从Android12开始，“/data/misc/perfetto-configs”可以用来存储配置文件，你也可以把自己的配置文件push到这个目录下，然后直接用命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>adb shell <span class="token parameter variable">-t</span> perfetto <span class="token parameter variable">-c</span> data/misc/perfetto-configs/config.pbtx <span class="token parameter variable">--txt</span> <span class="token parameter variable">-o</span> /data/misc/perfetto-traces/test2.perfetto-trace
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>来生成perfetto-trace文件：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images9035e87fe1d3491d8679c82678671fda.png" alt="在这里插入图片描述"></p><p>我个人觉得还是自己本地写好一个配置文件，然后执行：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> config.pbtx <span class="token operator">|</span> adb shell perfetto <span class="token parameter variable">-c</span> - <span class="token parameter variable">--txt</span> <span class="token parameter variable">-o</span> /data/misc/perfetto-traces/test.perfetto-trace
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种方式最简单快捷。</p><h2 id="分析跟踪记录" tabindex="-1"><a class="header-anchor" href="#分析跟踪记录" aria-hidden="true">#</a> 分析跟踪记录</h2><p>这部分官网已经讲的很详细了，我这边没有遇到什么别的问题。</p><h2 id="问题收集" tabindex="-1"><a class="header-anchor" href="#问题收集" aria-hidden="true">#</a> 问题收集</h2><p>如我之前所说，最开始我用的是公司机房的ubuntu系统的电脑，并且能够连接外网，所以遇到的问题还算少的。</p><p>但是我最终的目的肯定是在自己自用的电脑上用的，由于我本地是windows系统+WSL，不能连外网，并且代码是下载在服务器然后挂载到本地的，所以实际上操作的时候遇到了很多其它的问题。</p><h3 id="_1-直接使用index-html行吗" tabindex="-1"><a class="header-anchor" href="#_1-直接使用index-html行吗" aria-hidden="true">#</a> 1. 直接使用index.html行吗</h3><p>根据我们在Android15之前的平台上的经验，是可以直接把<code>prebuilts/misc/common/winscope/winscope.html</code>这个文件拷贝到其它地方，然后直接打开来用的，那现在对<code>development/tools/winscope/dist/prod/index.html</code>还可以用同样的操作吗？</p><p>我直接将机房生成的”dist/prod“目录拷到我本地，然后直接打开<code>development/tools/winscope/dist/prod/index.html</code>后，同样是这个界面：</p><p><img src="https://i-blog.csdnimg.cn/direct/f6c657c5cacb4f338ea15b85fa22a89c.png" alt="在这里插入图片描述"></p><p>然后我本地试了一下，大部分的文件都能拖进去解析：</p><p><img src="https://i-blog.csdnimg.cn/direct/485341a28d514869b7b9c0ceba09ed88.png" alt="在这里插入图片描述"></p><p>但是唯独<code>trace.perfetto-trace</code>不行！</p><p>说实话我用Winscope主要就是看SurfaceFlinger的信息的，你哪怕功能再多，SurfaceFlinger的信息看不了对我来说等于没用，目前我本地是行不通的。</p><p>~不知道有没有网上的各位大佬有没有办法，如果可以的话，就能省下很多工作了。~</p>`,38),F=e("br",null,null,-1),L={href:"https://blog.csdn.net/learnframework/article/details/144384808?spm=1001.2014.3001.5501",target:"_blank",rel:"noopener noreferrer"},T=i(`<h3 id="_2-解决html直接导入winscope文件" tabindex="-1"><a class="header-anchor" href="#_2-解决html直接导入winscope文件" aria-hidden="true">#</a> 2. 解决html直接导入Winscope文件</h3><p>1、用npm安好http-server</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> http-server
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、然后到cd到html目录执行http-server 例如我们到<code>development/tools/winscope/dist/prod</code>目录下执行http-server</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>test@test:~/aosp15/development/tools/winscope/dist/prod$ http-server 
Starting up http-server, serving ./

http-server version: <span class="token number">14.1</span>.1

http-server settings: 
CORS: disabled
Cache: <span class="token number">3600</span> seconds
Connection Timeout: <span class="token number">120</span> seconds
Directory Listings: visible
AutoIndex: visible
Serve GZIP Files: <span class="token boolean">false</span>
Serve Brotli Files: <span class="token boolean">false</span>
Default File Extension: none

Available on:
  http://127.0.0.1:8080
  http://192.168.31.142:8080
Hit CTRL-C to stop the server

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、进入浏览器，访问http://127.0.0.1:8080地址既可以</p><h3 id="_3-直接将别的机器的源码拷到本地可以吗" tabindex="-1"><a class="header-anchor" href="#_3-直接将别的机器的源码拷到本地可以吗" aria-hidden="true">#</a> 3. 直接将别的机器的源码拷到本地可以吗</h3><p>既然直接将<code>index.html</code>拿过来不行，那将别的机器中配置好的源码拷贝过来可以用吗？比如我在机器A上配置好了，然后我把机器A上的源码直接拷贝到机器B上，然后直接在<code>development/tools/winscope</code>目录下执行最后一步<code>npm run start</code>可以吗？毕竟能少执行一步就少执行一步…</p><p>实际上是可行的，但是根据我操作的情况，将机房中的机器A配置好的源码拷贝到机房中的机器B（同样的Ubuntu+连接外网）下是行得通的，但是拷贝到我自用的机器（Windows+WSL+不能连外网）就不行，具体现象和直接打开“index.html”是一样的，没办法查看perfetto-trace文件…时运不齐，命途多舛。</p><h3 id="_4-oserror-errno-98-address-already-in-use" tabindex="-1"><a class="header-anchor" href="#_4-oserror-errno-98-address-already-in-use" aria-hidden="true">#</a> 4. OSError: [Errno 98] Address already in use</h3><p>有的时候执行<code>winscope_proxy.py</code>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>python3 winscope_proxy.py
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>会提示：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>OSError: <span class="token punctuation">[</span>Errno <span class="token number">98</span><span class="token punctuation">]</span> Address already <span class="token keyword">in</span> use
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时执行：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">netstat</span> <span class="token parameter variable">-tunlp</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>kill掉相应的进程：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images3c68a2f5a6b9488fa4b1eacbb2a610f3.png" alt="在这里插入图片描述"></p><p>就可以了。</p><h3 id="_5-listen-eaddrinuse-address-already-in-use-8080" tabindex="-1"><a class="header-anchor" href="#_5-listen-eaddrinuse-address-already-in-use-8080" aria-hidden="true">#</a> 5. listen EADDRINUSE: address already in use :::8080</h3><p>有的时候执行<code>npm run start</code>，会遇到端口被占用的情况：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>listen EADDRINUSE: address already <span class="token keyword">in</span> use :::8080
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那么执行：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">lsof</span> <span class="token parameter variable">-i</span> :<span class="token operator">&lt;</span>端口号<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后kill掉相关进程就好了，如我这里的是8080端口号被占了：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesb4af6ea085bd4f348311d1f4c936bd3f.png" alt="在这里插入图片描述"></p><h2 id="小试牛刀-——-闪屏问题分析" tabindex="-1"><a class="header-anchor" href="#小试牛刀-——-闪屏问题分析" aria-hidden="true">#</a> 小试牛刀 —— 闪屏问题分析</h2><p>现在你已经掌握了Winscope的使用方法了，可以运用到实际来解决问题了，这里看一个启动头条闪屏的问题。</p><h3 id="_1-问题描述" tabindex="-1"><a class="header-anchor" href="#_1-问题描述" aria-hidden="true">#</a> 1. 问题描述</h3><p>非冷启动头条的情况，偶尔会出现闪屏的情况，如：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images7c0ea5b744204edca3d47a2277f396eb.png" alt="在这里插入图片描述"></p><p>看这个现象：</p><p>1、是Starting Window消失又出现了？</p><p>2、还是Starting Window消失后过了一阵子Activity界面显示了？</p><p>3、亦或是Starting Window根本就没有显示，是Activity界面消失又出现了？</p><p>…</p><p>可能的原因很多，单从问题场景无法得知原因。</p><h3 id="_2-分析方式一-添加log" tabindex="-1"><a class="header-anchor" href="#_2-分析方式一-添加log" aria-hidden="true">#</a> 2. 分析方式一：添加log</h3><p>在计算Layer可见区域的函数Output.ensureOutputLayerIfVisible中添加log，看到：</p><p>1、SnapshotStartingWindow先被显示：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images86193239574946c88e5a3249c4fd26a4.png" alt="在这里插入图片描述"></p><p>2、然后在真正的MainActivity显示之前，SnapshotStartingWindow被隐藏了：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images74296312629f4f6ea57ed16d4646282c.png" alt="在这里插入图片描述"></p><p>3、最终MainActivity显示：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images75ff565f776341249eedba2a6b9df526.png" alt="在这里插入图片描述"></p><p>4、正常来说，SnapshotStartingWindow应该是要等MainActivity显示了之后才隐藏的，如这份正常的log：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images60021512c758443688d9e74b5003085e.png" alt="在这里插入图片描述"></p><p>MainActivity显示的时候SnapshotStartingWindow还在，但是出现问题的时候，是提前隐藏了。</p><h3 id="_3-分析方式二-winscope" tabindex="-1"><a class="header-anchor" href="#_3-分析方式二-winscope" aria-hidden="true">#</a> 3. 分析方式二：Winscope</h3><p>以上方式显而易见，我们得有一套编译过的代码以及相匹配的手机才行，有的时候你可能手头没有这些，你要重新下一套代码再去编译啥的，很花时间，再看使用Winscope如何分析问题。</p><p>我这边只抓了SurfaceFlinger和视频的信息，当然也可以SurfaceFlinger和视频的信息结合着一起看，但是这样会比较卡，由于复现的时间比较长，所以我这边先查看了视频的信息，如下：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesbd24a5056a554352934066ebe136cbe1.png" alt="在这里插入图片描述"></p><p>上面显示的“f=…”应该是帧号的意思，那么看视频：</p><p>1）、大概是在1130帧的时候，头条的相关界面（可能是StartingWindow，也可能是头条的Activity，现在还不得而知）完全消失。</p><p>2）、1131帧的时候，Launcher界面也消失。</p><p>3）、1135帧的时候，头条的相关界面又重新出现。</p><p>再看Winscope的信息：</p><p>1、由于是1130帧出现了问题，那么首先看1129帧：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesfa3cc0c650004b688da371636f76c5e9.png" alt="在这里插入图片描述"></p><p>看视频的信息，知道此时头条的界面还在显示，从SurfaceFlinger的信息知，此时显示的是头条的StartingWindow。</p><p>展开看StartingWindow：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images269e5558cffc4e159e56ddf0e3e8470e.png" alt="在这里插入图片描述"></p><p>其Layer位于头条对应的Task#8之下，没毛病。</p><p>2、接着是1130帧：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images52f5043cb9f24cf3939684499b871142.png" alt="在这里插入图片描述"></p><p>看视频此时StartingWindow不见了，再看SurfaceFlinger的信息，头条的StartingWindow对应的可见Layer也不在了。</p><p>再展开看头条对应的Task#8的信息：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images8d38d27976b24ad0a4a363fa3d6cb109.png" alt="在这里插入图片描述"></p><p>发现StartingWindow的WindowState啥的全被移除了。</p><p>此时头条的MainActivity还没显示，但是StartingWindow已经被移除了，这个肯定是不对的。</p><p>3、最后看1135帧：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images5bc0395038ca43b5b5d58fde1b1aa3b9.png" alt="在这里插入图片描述"></p><p>看视频的信息，此时头条的界面又显示出来了，从SurfaceFlinger的信息知，此时显示的是头条的真正的界面，MainActivity。</p><p>根据Winscope显示的信息，我们可以和方式一添加log调试那样得出同样的结论，即StartingWindow被提前隐藏/移除了。</p><h3 id="_4-问题原因" tabindex="-1"><a class="header-anchor" href="#_4-问题原因" aria-hidden="true">#</a> 4. 问题原因</h3><p>根据以上分析，我们知道了闪屏的原因是因为StartingWindow被提前移除了，但是从Winscope上也无法再得出更多的信息了。</p><p>继续打开更多相关的log开关，主要是<code>WM_DEBUG_STARTING_WINDOW、WM_SHOW_TRANSACTIONS以及WM_SHOW_SURFACE_ALLOC</code>，并且结合我自己的log（有没有都行），抓取一份复现问题的log进行分析：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images46d31557ee544ece9d5fb138e3c1ffdc.png" alt="在这里插入图片描述"></p><p>log中的信息总结如下：</p><p>1、SnapshotStartingWindow窗口被添加、绘制完成以及SurfaceControl显示。</p><p>2、SnapshotStartingWindow对应的Layer显示。</p><p>3、头条的一个子窗口，PopupWindow，绘制完成，于是准备移除SnapshotStartingWindow，但是MainActivity的主窗口还没绘制完成。</p><p>4、WMS侧发起对SnapshotStartingWindow的隐藏和销毁。</p><p>5、SnapshotStartingWindow的Layer被隐藏，但是此时头条的MainActivity还没显示。</p><p>6、头条MainActivity的主窗口绘制完成、显示。</p><p>7、头条MainActivity主窗口对应的Layer显示。</p><p>关键就在于当头条的一个子窗口，PopupWindow，绘制完成后，即触发了：</p><p>ActivityRecord.onFirstWindowDrawn</p><p>-&gt; ActivityRecord.removeStartingWindow</p><p>-&gt; ActivityRecord.removeStartingWindowAnimation</p><p>移除了SnapshotStaringWindow。</p><p>但是实际上不管是看视频，还是看log，都是没找到这个PopupWindow的相关信息的，查看这个PopupWindow的信息：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images2ae60ae99bc94f16a84e9f9b3100da02.png" alt="在这里插入图片描述"></p><p>请求的宽是0，所以这个PopupWindow实际上是没有内容显示的，但是它绘制完成的时候，又认为此时可以移除SnapshotStartingWindow了，这肯定是不合理的。</p><h3 id="_5-pixel现象" tabindex="-1"><a class="header-anchor" href="#_5-pixel现象" aria-hidden="true">#</a> 5. pixel现象</h3><p>最后看到pixel上同样可以复现，log为：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images154aec3e142446f2ac4b9df0acb4f0de.png" alt="在这里插入图片描述"></p><p>原因是一样的，由于PopupWindow绘制完成，移除了SnapshotStartingWindow，而此时MainActivity的主窗口还没绘制完成，从而出现闪屏：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images886c51b4bcd94043ac8baf8eab984f79.png" alt="在这里插入图片描述"></p><h3 id="_6-小结" tabindex="-1"><a class="header-anchor" href="#_6-小结" aria-hidden="true">#</a> 6. 小结</h3><p>从本题的分析我们可以看到，如果是用Winscope分析这个问题的话，只需要两步：</p><p>1、手头任意一台能够复现问题的手机，用Winscope查看问题发生过程中的界面变化。</p><p>2、打开更多log开关，然后根据log查明问题发生的原因。</p><p>如果不用Winscope，那么我们的解题步骤是：</p><p>1、下一套代码，添加log，编译。</p><p>2、找个机器，刷和下载的代码日期相近的版本。</p><p>3、将编译出的东西push到手机，然后复现问题，根据log得知问题发生过程中的界面变化。</p><p>4、打开更多log开关，然后根据log查明问题发生的原因。</p><p>这种问题，耗时的地方往往在于前几步，因为log中没有信息来表明每时每刻屏幕上正在发生的界面变化，如果没有Winscope的话，那么我们只能搞一套代码，添加log来调试，非常麻烦。</p><p>但是Winscope也有局限性，大部分情况下我们无法只通过Winscope就知道问题原因，还是需要结合log或者其它工具来综合分析问题。</p>`,110),E={href:"https://blog.csdn.net/ukynho/article/details/143023774?spm=1001.2014.3001.5501",target:"_blank",rel:"noopener noreferrer"};function C(R,I){const n=r("ExternalLinkIcon");return p(),o("div",null,[e("p",null,[e("a",d,[a("使用 Winscope 跟踪窗口转换 | Android Open Source Project (google.cn)"),s(n)])]),l,e("p",null,[e("a",u,[a("使用 Winscope 跟踪窗口转换 | Android Open Source Project (google.cn)"),s(n)])]),g,m,h,b,v,f,e("p",null,[e("a",_,[a("android 14版本的winscope编译使用-手把手教你编译成功不报错_android wincope-CSDN博客"),s(n)])]),k,e("p",null,[a("1、"),e("a",w,[a("启用开发者选项"),s(n)]),a("。")]),x,e("p",null,[a("SurfaceFlinger 层跟踪使用 Perfetto 跟踪记录进行捕获。如需了解配置信息，请参阅"),e("a",S,[a("跟踪配置"),s(n)]),a("。")]),W,e("p",null,[e("a",A,[a("Trace configuration - Perfetto Tracing Docs"),s(n)])]),y,e("p",null,[a("该问题别的博主已经解决："),F,e("a",L,[a("aosp15上winscope离线html如何使用？_winscope.html-CSDN博客"),s(n)])]),T,e("p",null,[a("本文转自 "),e("a",E,[a("https://blog.csdn.net/ukynho/article/details/143023774?spm=1001.2014.3001.5501"),s(n)]),a("，如有侵权，请联系删除。")])])}const P=t(c,[["render",C],["__file","Android15shiyongWinscope.html.vue"]]);export{P as default};
