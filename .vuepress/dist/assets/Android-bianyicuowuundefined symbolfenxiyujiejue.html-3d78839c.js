import{_ as a,r as i,o as d,c as l,b as n,d as e,e as o,a as c}from"./app-e8f85126.js";const r={},t=c(`<p>最近在Android 12上写添加新的.c接口时遇到编译报错的问题，具体报错如下：</p><p><img src="https://raw.githubusercontent.com/shug666/image/main/images/image-20230518210501743.png" alt="image-20230518210501743"></p><h2 id="一、尝试解决" tabindex="-1"><a class="header-anchor" href="#一、尝试解决" aria-hidden="true">#</a> 一、尝试解决</h2><p>开始没认真分析报错的原因，直接在网上找答案了。看了网上的答案，基本上都是下面的答案：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>在Android.mk中添加 LOCAL_LDFLAGS :<span class="token operator">=</span> -Wl,--unresolved-symbols<span class="token operator">=</span>ignore-all
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然而，加上这句之后，依然还是报同样的错误，似乎他们的解决方法对这个问题不起作用。</p><p>这个方法意思是告诉编译器 绕过这些检查，因此如果您尝试使用库中确实不存在的函数，<code>ld</code>就没有机会警告您，一般是不能随便用的。</p><p>然后来分析这个报错，它提示 <code>undefined symbol</code>。因此尝试去解决这个报错，通过引用<code>system/core/libutils/include</code>来解决，具体修改如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>LOCAL_C_INCLUDES += \\
    system/core/libnetutils/include \\
    system/core/libutils/include \\
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后编译之后，依然报一样的错。</p><p><strong>后来，将 <code>include $(BUILD_EXECUTABLE)</code> 改成 <code>include $(BUILD_STATIC_LIBRARY)</code> 之后，竟然编译过了。因此，怀疑是 build系统不让通过<code>LOCAL_C_INCLUDES</code>的形式引用。</strong></p><p>虽然已经包含了头文件，但由于编译器找不到要链接的库。不过，由于他们是共享库，因此在构建的时候，并不是严格要求需要拥有这些库。</p><p>从Android高版本开始，Android ndk规定了第三方可以使用的稳定的api（可以查看google官方的介绍https://developer.android.google.cn/ndk/guides/stable_apis.html）。一般可以通过在<code>Android.mk</code>中添加以下行来包括：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>LOCAL_LDLIBS :<span class="token operator">=</span> <span class="token punctuation">\\</span>
  <span class="token parameter variable">--lfoo</span> <span class="token punctuation">\\</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>由于使用的库不是稳定api的一部分。这本质上意味着，即使你的代码在某个特定版本的android上工作，它也可能在任何更高版本上中断，因为api可能已经更改了。</p><p>由于这些库是共享的，ld所做的只是检查它们是否提供了您正在使用的函数。因此一种方法是提供存根库。</p><p>存根库本质上是一个虚拟库，它定义了与“真实”事物相同的符号（函数等），但没有实现（函数只是不做任何事情就返回）。这足以让链接器感到高兴，但这些库并没有提供，它们的“真正”对应项在运行时使用。您需要获取这个库<code>libutils</code>的源代码，它们位于以下目录中：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>system/core/libutils
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因此修改成如下的形式：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>LOCAL_SHARED_LIBRARIES :<span class="token operator">=</span> <span class="token punctuation">\\</span>
        libutils <span class="token punctuation">\\</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>还有一种方法是：将<code>system/core/libutils</code> 目录复制到项目目录下，然后去掉代码：</p><p>然后编辑<code>Android.mk</code>，删除<code>BUILD_SHARED_LIBRARY</code>以外的所有生成目标，再编辑源代码文件，用一个简单的<code>return</code> 替换所有函数体。返回什么并不重要，只是为了能编译代码。<br> 另外，可能需要防止存根库包含在编译出来的bin中。</p><h2 id="二、最终解决" tabindex="-1"><a class="header-anchor" href="#二、最终解决" aria-hidden="true">#</a> 二、最终解决</h2><p>在android.mk文件中添加<code>LOCAL_CFLAGS += -DDVB_STANDARD</code>这个语句,用于为当前模块添加预处理宏定义。</p><p>-D选项用来定义预处理宏格式为-Dname或-Dname=definition。所以这个语句定义了一个名为DVB_STANDARD的预处理宏。在C/C++源代码中,可以使用#ifdef来条件编译基于这个宏:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DVB_STANDARD</span></span>
    <span class="token comment">// 编译这段代码</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果源代码编译时DVB_STANDARD这个宏被定义,那么#ifdef中的代码块会被编译。否则会被跳过。这通常用于:</p><ol><li><p>编译平台相关的代码:比如基于不同标准或协议的代码可以用预处理宏进行条件编译。</p></li><li><p>编译调试用的代码:通过定义DEBUG宏可以编译额外的调试日志和断言。3.</p></li><li><p>打开/关闭某些功能:通过定义/不定义 Feature_X 宏可以编译对应的功能代码。所以,这个语句的作用是为当前模块定义DVB_STANDARD预处理宏,用于条件编译与DVB标准相关的源代码。在编译这个模块的源代码时,所有#ifdef DVB_STANDARD条件编译的代码块都会被编译。如果希望禁用这部分代码,只需要去掉这行语句,那么编译时DVB_STANDARD宏不会被定义,对应的条件编译代码块会被跳过</p></li></ol>`,28),p={href:"https://blog.csdn.net/k663514387/article/details/107107350/",target:"_blank",rel:"noopener noreferrer"};function u(m,v){const s=i("ExternalLinkIcon");return d(),l("div",null,[t,n("p",null,[e("本文转自 "),n("a",p,[e("https://blog.csdn.net/k663514387/article/details/107107350/"),o(s)]),e("，如有侵权，请联系删除。")])])}const h=a(r,[["render",u],["__file","Android-bianyicuowuundefined symbolfenxiyujiejue.html.vue"]]);export{h as default};
