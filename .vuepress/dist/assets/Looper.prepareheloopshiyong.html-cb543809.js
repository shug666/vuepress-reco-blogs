import{_ as o,o as r,c as n,b as e}from"./app-f541e591.js";const l={},p=e("p",null,"Android中的Looper类，是用来封装消息循环和消息队列的一个类，用于在android线程中进行消息处理。",-1),a=e("p",null,"handler其实可以看做是一个工具类，用来向消息队列中插入消息的。",-1),t=e("ol",null,[e("li",null,[e("p",null,"Looper类用来为一个线程开启一个消息循环。 默认情况下android中新诞生的线程是没有开启消息循环的。（主线程除外，主线程系统会自动为其创建Looper对象，开启消息循环。） Looper对象通过MessageQueue来存放消息和事件。一个线程只能有一个Looper，对应一个MessageQueue。")]),e("li",null,[e("p",null,"通常是通过Handler对象来与Looper进行交互的。Handler可看做是Looper的一个接口，用来向指定的Looper发送消息及定义处理方法。 默认情况下Handler会与其被定义时所在线程的Looper绑定，比如，Handler在主线程中定义，那么它是与主线程的Looper绑定。 mainHandler = new Handler() 等价于new Handler（Looper.myLooper()）. Looper.myLooper()：获取当前进程的looper对象，类似的 Looper.getMainLooper() 用于获取主线程的Looper对象。")]),e("li",null,[e("p",null,"在非主线程中直接new Handler() 会报如下的错误: E/AndroidRuntime( 6173): Uncaught handler: thread Thread-8 exiting due to uncaught exception E/AndroidRuntime( 6173): java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare() 原因是非主线程中默认没有创建Looper对象，需要先调用Looper.prepare()启用Looper。")]),e("li",null,[e("p",null,"Looper.loop(); 让Looper开始工作，从消息队列里取消息，处理消息。"),e("p",null,"注意：写在Looper.loop()之后的代码不会被执行，这个函数内部应该是一个循环，当调用mHandler.getLooper().quit()后，loop才会中止，其后的代码才能得以运行。")])],-1),d=[p,a,t];function i(u,s){return r(),n("div",null,d)}const c=o(l,[["render",i],["__file","Looper.prepareheloopshiyong.html.vue"]]);export{c as default};
