import{_ as e,r as t,o as p,c as o,b as s,d as n,e as i,a as l}from"./app-e8f85126.js";const c={},u=l(`<h2 id="开始" tabindex="-1"><a class="header-anchor" href="#开始" aria-hidden="true">#</a> 开始</h2><p>Kotlin 有个特别好用的功能叫扩展，你可以给已有的类去额外添加函数和属性，而且既不需要改源码也不需要写子类。这就是今天这个视频的主题。另外很多人虽然会用扩展，但只会最基本的使用，比如就只用来写个叫 <code>dp</code> 的扩展属性来把 dp 值转成像素值：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> Float<span class="token punctuation">.</span>dp
  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> TypedValue<span class="token punctuation">.</span><span class="token function">applyDimension</span><span class="token punctuation">(</span>
    TypedValue<span class="token punctuation">.</span>COMPLEX_UNIT_DIP<span class="token punctuation">,</span>
    <span class="token keyword">this</span><span class="token punctuation">,</span>
    Resources<span class="token punctuation">.</span><span class="token function">getSystem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>displayMetrics
  <span class="token punctuation">)</span>

<span class="token operator">..</span><span class="token punctuation">.</span>

<span class="token keyword">val</span> RADIUS <span class="token operator">=</span> <span class="token number">200f</span><span class="token punctuation">.</span>dp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>稍微高级一点就不太行了，尤其是扩展函数和函数引用混在一起的时候就更是瞬间蒙圈。如果你有这样的问题，这个视频应该可以帮到你。</p><h2 id="java-的-math-pow" tabindex="-1"><a class="header-anchor" href="#java-的-math-pow" aria-hidden="true">#</a> Java 的 Math.pow()</h2><p>在 Java 里我们如果想做幂运算——也就是几的几次方——要用静态方法 <code>pow(a, n)</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 的 10 次方</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>pow 这个词你可能不认识，其实它不是个完整的词，而是 power 的缩写，power 就是乘方的意思，哎中国人学程序经常还需要学英文好烦。这个 <code>pow(a, n)</code> 方法是 <code>Math</code> 类的一个静态方法，这类方法我们用得比较多的是 <code>max()</code> 和 <code>min()</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>比较两个数的大小，用静态方法很符合直觉；但是幂运算的话，静态方法就不如成员方法来得更直观了：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token number">2.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 要是 Java 里能这样写就好了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但我们只能选择静态方法。为什么？很简单，因为 Integer、Float、Double 这几个类没提供这个方法，所以我们只能用 Math 类的静态方法。</p><h2 id="kotlin-的扩展函数-float-pow" tabindex="-1"><a class="header-anchor" href="#kotlin-的扩展函数-float-pow" aria-hidden="true">#</a> Kotlin 的扩展函数 Float.pow()</h2><p>在 Kotlin 里，我们用的不是 Java 的 Integer、Float、Double，而是另外几个名字相同或相像的 Kotlin 自己新创造的类。这几个类同样没有提供 <code>pow()</code> 这个函数，但好的是，我们依然可以用看起来像是成员函数的方式来做幂运算。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token number">2f</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// Kotlin 可以这么写</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为什么？因为 <code>Float.pow(n: Int)</code> 是 Kotlin 给 <code>Float</code> 这个类增加的一个扩展函数：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// kotlin.util.MathJVM.kt</span>
<span class="token keyword">public</span> <span class="token keyword">actual</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> Float<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>n<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> Float
    <span class="token operator">=</span> nativeMath<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">.</span><span class="token function">toDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在声明一个函数的时候在函数名的左边写个类名再加个点，你就能对这个类的对象调用这个函数了。这种函数就叫扩展函数，Extension Functions。就好像你钻到这个类的源码里，改了它的代码，给它增加了一个新的函数一样。虽然事实上不是，但用起来基本一样。具体区别我等会儿说。</p><p>这种用法给我们的开发带来了极大的便利，我们可以用它来做很多事。</p><p>举个例子？</p><ul><li><p>比如 pow() 吧？</p></li><li><p>再比如，AndroidX 里有个东西叫 ViewModel 对吧？——这个我以后有空的话也讲一下，很多人对 ViewModel 有很大误解，竟然以为这是用来写 MVVM 架构的——AndroidX 的 KTX 库里有一个对于 ComponentActivity 类的扩展函数叫 viewModels()：</p></li><li><p><img src="https://raw.githubusercontent.com/shug666/image/main/imagesrxkdvv.jpg" alt="rxkdvv"></p><p>只要引用了对应的 KTX 库，在 Activity 里你可以直接就调用这个函数来很方便地初始化 ViewModel：</p></li></ul><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> MainActivity <span class="token operator">:</span> <span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">val</span> model<span class="token operator">:</span> MyViewModel <span class="token keyword">by</span> <span class="token function">viewModels</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token operator">..</span><span class="token punctuation">.</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而不需要重写 Activity 类。</p><ul><li>类似的用法可以有很多很多，限制你的是你的想象力。所以其实对于扩展函数，你更需要注意的是谨慎和克制：需要用了再用，而不要因为它很酷很方便就能用则用。因为这些方便的东西如果太多，就会变成对你和同事的打扰。</li></ul><h2 id="扩展函数的写法" tabindex="-1"><a class="header-anchor" href="#扩展函数的写法" aria-hidden="true">#</a> 扩展函数的写法</h2><p>扩展函数写在哪都可以，但写的位置不同，作用域就也不同。所谓作用域就是说你能在哪些地方调用到它。</p><p>最简单的写法就是把它写成 Top Level 也就是顶层的，让它不属于任何类，这样你就能在任何类里使用它。这也和成员函数的作用域很像——哪里能用到这个类，哪里就能用到类里的这个函数：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">package</span> com<span class="token punctuation">.</span>rengwuxian

<span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token operator">..</span><span class="token punctuation">.</span>

<span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有一点要注意了：这个函数属于谁？属于函数名左边的类吗？并不是的，它是个 Top-level Function，它谁也不属于，或者说它只属于它所在的 package。</p><p>那它为什么可以被这个类的对象调用呢？——因为它在函数名的左边呀！在 Kotlin 里，当你给声明的函数名左边加上一个类名的时候，表示你要给这个函数限定一个 Receiver——直译的话叫接收者，其实也就是哪个类的对象可以调用这个函数。虽然说你是个 Top-level Function，不属于任何类——确切地说是，不是任何一个类的成员函数——但我要限制只有通过某个类的对象才能调用你。这就是扩展函数的本质。<br> 那这……和成员函数有什么区别吗？这种奇怪又绕脑子的知识有什么用吗？听我继续讲。</p><h2 id="成员扩展函数" tabindex="-1"><a class="header-anchor" href="#成员扩展函数" aria-hidden="true">#</a> 成员扩展函数</h2><p>除了写成 Top Level 的，扩展函数也可以写在某个类里：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> Example <span class="token punctuation">{</span>

  <span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后你就可以在这个类里调用这个函数，但必须使用那个前缀类的对象来调用它：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> Example <span class="token punctuation">{</span>

  <span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>

  <span class="token operator">..</span><span class="token punctuation">.</span>

  <span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 可以调用</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看起来……有点奇怪了。这个函数这么写，它到底是属于谁的呀？属于外部的类还是左边前缀的类？<br> 属于谁？这个「属于谁」其实有点模糊的，我需要问再明确点：它是谁的成员函数？当然是外部的类的成员函数了，因为它写在它里面嘛，对吧？那函数名左边的是什么？刚才我刚说过，它是这个函数的 Receiver，对吧？也就是谁可以去调用它。<br> 所以它既是外部类的成员函数，又是前缀类的扩展函数。<br> 这种既是成员函数、又是扩展函数的函数，它们的用法跟 Top Level 的扩展函数一样，只是由于它同时还是成员函数，所以只能在它所属的类里面被调用，到了外面就不能用了：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> Example <span class="token punctuation">{</span>

  <span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>

  <span class="token operator">..</span><span class="token punctuation">.</span>

  <span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 可以调用</span>

<span class="token punctuation">}</span>

<span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 类的外部不能调用</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个……也好理解吧？你为什么要把扩展函数写在类的里面？不就是为了让它不要被外界看见造成污染吗，是吧？</p><h2 id="指向扩展函数的引用" tabindex="-1"><a class="header-anchor" href="#指向扩展函数的引用" aria-hidden="true">#</a> 指向扩展函数的引用</h2><p>在之前 Lambda 那一期视频里，我说过函数是可以使用双冒号被指向的对吧：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>Int<span class="token operator">::</span>toFloat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我当时也讲了，其实指向的并不是函数本身，而是和函数等价的一个对象，这也是为什么你可以对这个引用调用 invoke()，却不能对函数本身调用：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token punctuation">(</span>Int<span class="token operator">::</span>toFloat<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 等价于 1.toFloat()</span>
Int<span class="token operator">::</span>toFloat<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 等价于 1.toFloat()</span>
<span class="token number">1</span><span class="token punctuation">.</span>toFloat<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是为了简单起见，我们通常可以把这个「指向和函数等价的对象的引用」称作是「指向这个函数的引用」，这个问题不大。那么我们基于这个叫法继续说。</p><p>普通函数可以被指向，扩展函数同样也是可以被指向的：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token operator">..</span><span class="token punctuation">.</span>

String<span class="token operator">::</span>method1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过如果这个扩展函数不是 Top-Level 的，也就是说如果它是某个类的成员函数，它就不能被引用了：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> Extensions <span class="token punctuation">{</span>

  <span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>

  <span class="token operator">..</span><span class="token punctuation">.</span>

  String<span class="token operator">::</span>method1 <span class="token comment">// 报错</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么？你想啊，一个成员函数怎么引用：类名加双冒号加函数名对吧？扩展函数呢？也是类名加双冒号加函数名对吧？只不过这次是 Receiver 的类名。那成员扩展函数呢？还用类名加双冒号加函数名呗？但是……用谁的类名？是这个函数所属的类名，还是它的 Receiver 的类名？这是有歧义的，所以 Kotlin 就干脆不许我们引用既是成员函数又是扩展函数的函数了，一了百了。</p><p>同样，跟普通函数的引用一样，扩展函数的引用也可以被调用，直接调用或者用 invoke() 都可以，不过要记得把 Receiver 也就是接收者或者说调用者填成第一个参数：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token punctuation">(</span>String<span class="token operator">::</span>method1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
String<span class="token operator">::</span>method1<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>

<span class="token comment">// 以上两句都等价于：</span>
<span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="把扩展函数的引用赋值给变量" tabindex="-1"><a class="header-anchor" href="#把扩展函数的引用赋值给变量" aria-hidden="true">#</a> 把扩展函数的引用赋值给变量</h3><p>同样的，扩展函数的引用也可以赋值给变量：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> a<span class="token operator">:</span> String<span class="token punctuation">.</span><span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> String<span class="token operator">::</span>method1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后你再拿着这个变量去调用，或者再次传递给别的变量，都是可以的：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
a<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="有无-receiver-的变量的互换" tabindex="-1"><a class="header-anchor" href="#有无-receiver-的变量的互换" aria-hidden="true">#</a> 有无 Receiver 的变量的互换</h3><p>另外大家可能会发现，当你拿着一个函数的引用去调用的时候，不管是一个普通的成员函数还是扩展函数，你都需要把 Receiver 也就是接收者或者调用者作为第一个参数填进去。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token punctuation">(</span>String<span class="token operator">::</span>method1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 等价于 &quot;rengwuxian&quot;.method1(1)</span>
<span class="token punctuation">(</span>Int<span class="token operator">::</span>toFloat<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 等价于 1.toFloat()</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么？因为你拿到的是函数引用而不是调用者的对象，所以没办法在左边写上调用者啊，是吧？</p><p>所以 Kotlin 要想支持让我们拿着函数的引用去调用，就必须给个途径让我们提供调用者。那提供怎样的途径呢？最终 Kotlin 给我们的方案就是：在这种调用方式下，增加一个函数参数，让我们把第一个参数的位置填上调用者。这样，我们就可以用函数的引用来调用成员函数和扩展函数了。但同时，又有一个问题我不知道你们发现没有：</p><p>既然有 Receiver 的函数可以以无 Receiver 的方式来调用，那……它可以赋值给无 Receiver 的函数类型的变量吗？</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> b<span class="token operator">:</span> <span class="token punctuation">(</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> String<span class="token operator">::</span>method1 <span class="token comment">// 这样可以吗？</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>答案是，可以的。在 Kotlin 里，每一个有 Receiver 的函数——其实就是成员函数和扩展函数——它的引用都可以赋值给两种不同的函数类型变量：一种是有 Receiver 的，一种是没有 Receiver 的：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> a<span class="token operator">:</span> String<span class="token punctuation">.</span><span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> String<span class="token operator">::</span>method1
<span class="token keyword">val</span> b<span class="token operator">:</span> <span class="token punctuation">(</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> String<span class="token operator">::</span>method1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这两种写法都是合法的。为什么？因为有用啊，是吧？有什么用我刚讲过，忘了的倒个带。</p><blockquote><p>蔡依林：「终于看开……」</p></blockquote><p>而且同样的，这两种类型的变量也可以互相赋值来进行转换：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> a<span class="token operator">:</span> String<span class="token punctuation">.</span><span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> String<span class="token operator">::</span>method1
<span class="token keyword">val</span> b<span class="token operator">:</span> <span class="token punctuation">(</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> String<span class="token operator">::</span>method1
<span class="token keyword">val</span> c<span class="token operator">:</span> String<span class="token punctuation">.</span><span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> b
<span class="token keyword">val</span> d<span class="token operator">:</span> <span class="token punctuation">(</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> a
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>懵了？懵就对了，不要急，继续看，知识掌握住了，下去慢慢试慢慢琢磨。</p><h2 id="继续" tabindex="-1"><a class="header-anchor" href="#继续" aria-hidden="true">#</a> 继续</h2><p>继续讲。</p><p>既然这两种类型的变量可以互相赋值来转换，那不就是说无 Receiver 的函数引用也可以赋值给有 Receiver 的变量？ 这样的话，是不是一个普通的无 Receiver 的函数也可以直接赋值给有 Receiver 的变量？</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">method3</span><span class="token punctuation">(</span>s<span class="token operator">:</span> String<span class="token punctuation">,</span> i<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token operator">..</span><span class="token punctuation">.</span>

<span class="token keyword">val</span> e<span class="token operator">:</span> <span class="token punctuation">(</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> <span class="token operator">::</span>method3
<span class="token keyword">val</span> f<span class="token operator">:</span> String<span class="token punctuation">.</span><span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> <span class="token operator">::</span>method3 <span class="token comment">// 这种写法也行哦</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哇塞，没有报错！</p><p>是的，这样赋值也是可以的。</p><p>通过这些类型的互相转换，你可以把一个本来没有 Receiver 的函数变得可以通过 Receiver 来调用：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">method3</span><span class="token punctuation">(</span>s<span class="token operator">:</span> String<span class="token punctuation">,</span> i<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token operator">..</span><span class="token punctuation">.</span>

<span class="token keyword">val</span> f<span class="token operator">:</span> String<span class="token punctuation">.</span><span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> <span class="token operator">::</span>method3
<span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">.</span><span class="token function">method3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 不允许调用，报错</span>
<span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 可以调用</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就很爽了哈？</p><p>当然了你也可以反向操作，去把一个有 Receiver 的函数变得不能用 Receiver 调用：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token operator">..</span><span class="token punctuation">.</span>

<span class="token keyword">val</span> b<span class="token operator">:</span> <span class="token punctuation">(</span>String<span class="token punctuation">,</span> Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> String<span class="token operator">::</span>method1
<span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 可以调用</span>
<span class="token string-literal singleline"><span class="token string">&quot;rengwuxian&quot;</span></span><span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 不允许调用，报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样收窄功能好像没什么用哈？不过我还是要把这个告诉你，因为这样你的知识体系才是完整的。</p><p>说到完整啊，每个做 Android 的人都应该把自己的支撑体系扩充一下，让自己的技能树变完整，你才能百毒不侵，工作和面试都不怕。那要怎么完整呢？最好的方式就是来学习一下我的 Android 高级进阶系列化课程。扫描屏幕上的二维码，加我的助教，更多课程相关的信息以及我更多的知识输出渠道找 TA 了解。</p><h2 id="扩展属性" tabindex="-1"><a class="header-anchor" href="#扩展属性" aria-hidden="true">#</a> 扩展属性</h2><p>除了扩展函数，Kotlin 的扩展还包括扩展属性。它跟扩展函数是一个逻辑，就是在声明的属性左边写上类名加点，这就是一个扩展属性了，英文原名叫 Extension Property。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> Float<span class="token punctuation">.</span>dp
  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> TypedValue<span class="token punctuation">.</span><span class="token function">applyDimension</span><span class="token punctuation">(</span>
    TypedValue<span class="token punctuation">.</span>COMPLEX_UNIT_DIP<span class="token punctuation">,</span>
    <span class="token keyword">this</span><span class="token punctuation">,</span>
    Resources<span class="token punctuation">.</span><span class="token function">getSystem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>displayMetrics
  <span class="token punctuation">)</span>

<span class="token operator">..</span><span class="token punctuation">.</span>

<span class="token keyword">val</span> RADIUS <span class="token operator">=</span> <span class="token number">200f</span><span class="token punctuation">.</span>dp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的用法和扩展函数一样，但少了扩展函数在引用上以及 Receiver 上的一些比较绕的问题，所以很简单，你自己去研究吧。有些东西写成扩展属性是比扩展函数要更加直观和方便的，所以虽然它很简单，但研究一下绝对有好处。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>这次讲的内容挺多的，但其实也很简单，主要就这么几点：扩展函数、扩展函数的引用、有无 Receiver 的函数类型的转换以及扩展属性。</p>`,89),r={href:"https://rengwuxian.com/kotlin-extensions/",target:"_blank",rel:"noopener noreferrer"};function d(k,v){const a=t("ExternalLinkIcon");return p(),o("div",null,[u,s("p",null,[n("本文转自 "),s("a",r,[n("https://rengwuxian.com/kotlin-extensions/"),i(a)]),n("，如有侵权，请联系删除。")])])}const b=e(c,[["render",d],["__file","Kotlindekuozhanhanshuhekuozhanshuxing.html.vue"]]);export{b as default};
