import{_ as p,r as o,o as c,c as i,b as n,d as s,e,a as t}from"./app-e8f85126.js";const l={},u=n("h2",{id:"协程是什么",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#协程是什么","aria-hidden":"true"},"#"),s(" 协程是什么")],-1),d=n("p",null,"协程并不是 Kotlin 提出来的新概念，其他的一些编程语言，例如：Go、Python 等都可以在语言层面上实现协程，甚至是 Java，也可以通过使用扩展库来间接地支持协程。",-1),r=n("p",null,"当在网上搜索协程时，我们会看到：",-1),k=n("ul",null,[n("li",null,"Kotlin 官方文档说「本质上，协程是轻量级的线程」。"),n("li",null,"很多博客提到「不需要从用户态切换到内核态」、「是协作式的」等等。")],-1),v=n("p",null,[s("作为 Kotlin 协程的初学者，这些概念并不是那么容易让人理解。这些往往是作者根据自己的经验总结出来的，只看结果，而"),n("strong",null,"不管过程就不容易理解协程"),s("。")],-1),m={href:"https://rengwuxian.com/%5Bhttps://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E6%96%87%C2%B7%E5%BA%B7%E5%A8%81%5D(https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E6%96%87%C2%B7%E5%BA%B7%E5%A8%81)",target:"_blank",rel:"noopener noreferrer"},b=n("strong",null,"协程是一种编程思想",-1),g=t(`<p>Go 语言也有协程，叫 Goroutines，从英文拼写就知道它和 Coroutines 还是有些差别的（设计思想上是有关系的），否则 Kotlin 的协程完全可以叫 Koroutines 了。</p><p>因此，对一个新术语，我们需要知道什么是「标准」术语，什么是变种。</p><p>当我们讨论协程和线程的关系时，很容易<strong>陷入中文的误区</strong>，两者都有一个「程」字，就觉得有关系，其实就英文而言，Coroutines 和 Threads 就是两个概念。</p><p>从 Android 开发者的角度去理解它们的关系：</p><ul><li>我们所有的代码都是跑在线程中的，而线程是跑在进程中的。</li><li>协程没有直接和操作系统关联，但它不是空中楼阁，它也是跑在线程中的，可以是单线程，也可以是多线程。</li><li>单线程中的协程总的执行时间并不会比不用协程少。</li><li>Android 系统上，如果在主线程进行网络请求，会抛出 <code>NetworkOnMainThreadException</code>，对于在主线程上的协程也不例外，这种场景使用协程还是要切线程的。</li></ul><p>协程设计的初衷是为了解决并发问题，让 「协作式多任务」 实现起来更加方便。这里就先不展开「协作式多任务」的概念，等我们学会了怎么用再讲。</p><p>视频里讲到，协程就是 Kotlin 提供的一套线程封装的 API，但并不是说协程就是为线程而生的。</p><p>不过，我们学习 Kotlin 中的协程，一开始确实可以从线程控制的角度来切入。因为在 Kotlin 中，协程的一个典型的使用场景就是线程控制。就像 Java 中的 <code>Executor</code> 和 Android 中的 <code>AsyncTask</code>，Kotlin 中的协程也有对 Thread API 的封装，让我们可以在写代码时，不用关注多线程就能够很方便地写出并发操作。</p><p>在 Java 中要实现并发操作通常需要开启一个 <code>Thread</code> ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里仅仅只是开启了一个新线程，至于它何时结束、执行结果怎么样，我们在主线程中是无法直接知道的。</p><p>Kotlin 中同样可以通过线程的方式去写：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，和 Java 一样也摆脱不了直接使用 <code>Thread</code> 的那些困难和不方便：</p><ul><li>线程什么时候执行结束</li><li>线程间的相互通信</li><li>多个线程的管理</li></ul><p>我们可以用 Java 的 <code>Executor</code> 线程池来进行线程管理：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">val</span> executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用 Android 的 <code>AsyncTask</code> 来解决线程间通信：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">object</span> <span class="token operator">:</span> AsyncTask&amp;lt<span class="token punctuation">;</span>T0<span class="token punctuation">,</span> T1<span class="token punctuation">,</span> T2&amp;gt<span class="token punctuation">;</span> <span class="token punctuation">{</span> 
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">doInBackground</span><span class="token punctuation">(</span><span class="token keyword">vararg</span> args<span class="token operator">:</span> T0<span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onProgressUpdate</span><span class="token punctuation">(</span><span class="token keyword">vararg</span> args<span class="token operator">:</span> T1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onPostExecute</span><span class="token punctuation">(</span>t3<span class="token operator">:</span> T3<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>AsyncTask</code> 是 Android 对线程池 <code>Executor</code> 的封装，但它的缺点也很明显：</p><ul><li>需要处理很多回调，如果业务多则容易陷入「回调地狱」。</li><li>硬是把业务拆分成了前台、中间更新、后台三个函数。</li></ul><p>看到这里你很自然想到使用 RxJava 解决回调地狱，它确实可以很方便地解决上面的问题。</p><p>RxJava，准确来讲是 ReactiveX 在 Java 上的实现，是一种响应式程序框架，我们通过它提供的「Observable」的编程范式进行链式调用，可以很好地消除回调。</p><p>使用协程，同样可以像 Rx 那样有效地消除回调地狱，不过无论是设计理念，还是代码风格，两者是有很大区别的，协程在写法上和普通的顺序代码类似。</p><blockquote><p>这里并不会比较 RxJava 和协程哪个好，或者讨论谁取代谁的问题，我这里只给出一个建议，你最好都去了解下，因为协程和 Rx 的设计思想本来就不同。</p></blockquote><p>下面的例子是使用协程进行网络请求获取用户信息并显示到 UI 控件上：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token function">launch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token keyword">val</span> user <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 👈 网络请求（IO 线程）</span>
    nameTv<span class="token punctuation">.</span>text <span class="token operator">=</span> user<span class="token punctuation">.</span>name  <span class="token comment">// 👈 更新 UI（主线程）</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里只是展示了一个代码片段，<code>launch</code> 并不是一个顶层函数，它必须在一个对象中使用，我们之后再讲，这里只关心它内部业务逻辑的写法。</p><p><code>launch</code> 函数加上实现在 <code>{}</code> 中具体的逻辑，就构成了一个协程。</p><p>通常我们做网络请求，要不就传一个 callback，要不就是在 IO 线程里进行阻塞式的同步调用，而在这段代码中，上下两个语句分别工作在两个线程里，但写法上看起来和普通的单线程代码一样。</p><p>这里的 <code>api.getUser</code> 是一个<strong>挂起函数</strong>，所以能够保证 <code>nameTv.text</code> 的正确赋值，这就涉及到了协程中最著名的「非阻塞式挂起」。这个名词看起来不是那么容易理解，我们后续的文章会专门对这个概念进行讲解。现在先把这个概念放下，只需要记住协程就是这样写的就行了。</p><p>这种「用同步的方式写异步的代码」看起来很方便吧，那么我们来看看协程具体好在哪。</p><h2 id="协程好在哪" tabindex="-1"><a class="header-anchor" href="#协程好在哪" aria-hidden="true">#</a> 协程好在哪</h2><h3 id="开始之前" tabindex="-1"><a class="header-anchor" href="#开始之前" aria-hidden="true">#</a> 开始之前</h3><p>在讲之前，我们需要先了解一下「闭包」这个概念，调用 Kotlin 协程中的 API，经常会用到闭包写法。</p><p>其实闭包并不是 Kotlin 中的新概念，在 Java 8 中就已经支持。</p><p>我们先以 <code>Thread</code> 为例，来看看什么是闭包：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token comment">// 创建一个 Thread 的完整写法</span>
<span class="token function">Thread</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> Runnable <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 满足 SAM，先简化为</span>
<span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 使用闭包，再简化为</span>
Thread <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>形如 <code>Thread {...}</code> 这样的结构中 <code>{}</code> 就是一个闭包。</p><p>在 Kotlin 中有这样一个语法糖：当函数的最后一个参数是 lambda 表达式时，可以将 lambda 写在括号外。这就是它的闭包原则。</p>`,40),h=n("code",null,"Runnable",-1),f=n("code",null,"Runnable",-1),x=n("code",null,"run",-1),I={href:"https://medium.com/tompee/idiomatic-kotlin-lambdas-and-sam-constructors-fe2075965bfb?ref=rengwuxian.com",target:"_blank",rel:"noopener noreferrer"},w=n("code",null,"Thread {...}",-1),y=t(`<p>对于上文所使用的 <code>launch</code> 函数，可以通过闭包来进行简化 ：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
launch <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h3><p>前面提到，<code>launch</code> 函数不是顶层函数，是不能直接用的，可以使用下面三种方法来创建协程：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token comment">// 方法一，使用 runBlocking 顶层函数</span>
runBlocking <span class="token punctuation">{</span>
    <span class="token function">getImage</span><span class="token punctuation">(</span>imageId<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 方法二，使用 GlobalScope 单例对象</span>
<span class="token comment">//            👇 可以直接调用 launch 开启协程</span>
GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
    <span class="token function">getImage</span><span class="token punctuation">(</span>imageId<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 方法三，自行通过 CoroutineContext 创建一个 CoroutineScope 对象</span>
<span class="token comment">//                                    👇 需要一个类型为 CoroutineContext 的参数</span>
<span class="token keyword">val</span> coroutineScope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
    <span class="token function">getImage</span><span class="token punctuation">(</span>imageId<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>方法一通常适用于单元测试的场景，而业务开发中不会用到这种方法，因为它是线程阻塞的。</li><li>方法二和使用 <code>runBlocking</code> 的区别在于不会阻塞线程。但在 Android 开发中同样不推荐这种用法，因为它的生命周期会和 app 一致，且不能取消（什么是协程的取消后面的文章会讲）。</li><li>方法三是比较推荐的使用方法，我们可以通过 <code>context</code> 参数去管理和控制协程的生命周期（这里的 <code>context</code> 和 Android 里的不是一个东西，是一个更通用的概念，会有一个 Android 平台的封装来配合使用）。</li></ul><p>关于 <code>CoroutineScope</code> 和 <code>CoroutineContext</code> 的更多内容后面的文章再讲。</p><p>协程最常用的功能是并发，而并发的典型场景就是多线程。可以使用 <code>Dispatchers.IO</code> 参数把任务切到 IO 线程执行：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以使用 <code>Dispatchers.Main</code> 参数切换到主线程：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以在「协程是什么」一节中讲到的异步请求的例子完整写出来是这样的：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 在主线程开启协程</span>
    <span class="token keyword">val</span> user <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// IO 线程执行网络请求</span>
    nameTv<span class="token punctuation">.</span>text <span class="token operator">=</span> user<span class="token punctuation">.</span>name  <span class="token comment">// 主线程更新 UI</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而通过 Java 实现以上逻辑，我们通常需要这样写：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
api<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callback</span><span class="token operator">&amp;</span>lt<span class="token punctuation">;</span><span class="token class-name">User</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">success</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">runOnUiThread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                nameTv<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">failure</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种回调式的写法，打破了代码的顺序结构和完整性，读起来相当难受。</p><h3 id="协程的「1-到-0」" tabindex="-1"><a class="header-anchor" href="#协程的「1-到-0」" aria-hidden="true">#</a> 协程的「1 到 0」</h3><p>对于回调式的写法，如果并发场景再复杂一些，代码的嵌套可能会更多，这样的话维护起来就非常麻烦。但如果你使用了 Kotlin 协程，多层网络请求只需要这么写：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// 开始协程：主线程</span>
    <span class="token keyword">val</span> token <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment">// 网络请求：IO 线程</span>
    <span class="token keyword">val</span> user <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span>               <span class="token comment">// 网络请求：IO 线程</span>
    nameTv<span class="token punctuation">.</span>text <span class="token operator">=</span> user<span class="token punctuation">.</span>name                     <span class="token comment">// 更新 UI：主线程</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果遇到的场景是多个网络请求需要等待所有请求结束之后再对 UI 进行更新。比如以下两个请求：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
api<span class="token punctuation">.</span><span class="token function">getAvatar</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
api<span class="token punctuation">.</span><span class="token function">getCompanyLogo</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用回调式的写法，那么代码可能写起来既困难又别扭。于是我们可能会选择妥协，通过先后请求代替同时请求：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
api<span class="token punctuation">.</span><span class="token function">getAvatar</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span> avatar <span class="token operator">-</span>&amp;gt<span class="token punctuation">;</span>
    api<span class="token punctuation">.</span><span class="token function">getCompanyLogo</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span> logo <span class="token operator">-</span>&amp;gt<span class="token punctuation">;</span>
        <span class="token function">show</span><span class="token punctuation">(</span><span class="token function">merge</span><span class="token punctuation">(</span>avatar<span class="token punctuation">,</span> logo<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际开发中如果这样写，本来能够并行处理的请求被强制通过串行的方式去实现，可能会导致等待时间长了一倍，也就是性能差了一倍。</p><p>而如果使用协程，可以直接把两个并行请求写成上下两行，最后再把结果进行合并即可：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//            👇  async 函数之后再讲</span>
    <span class="token keyword">val</span> avatar <span class="token operator">=</span> async <span class="token punctuation">{</span> api<span class="token punctuation">.</span><span class="token function">getAvatar</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token comment">// 获取用户头像</span>
    <span class="token keyword">val</span> logo <span class="token operator">=</span> async <span class="token punctuation">{</span> api<span class="token punctuation">.</span><span class="token function">getCompanyLogo</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token comment">// 获取用户所在公司的 logo</span>
    <span class="token keyword">val</span> merged <span class="token operator">=</span> <span class="token function">suspendingMerge</span><span class="token punctuation">(</span>avatar<span class="token punctuation">,</span> logo<span class="token punctuation">)</span>    <span class="token comment">// 合并结果</span>
    <span class="token comment">//                  👆</span>
    <span class="token function">show</span><span class="token punctuation">(</span>merged<span class="token punctuation">)</span> <span class="token comment">// 更新 UI</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，即便是比较复杂的并行网络请求，也能够通过协程写出结构清晰的代码。需要注意的是 <code>suspendingMerge</code> 并不是协程 API 中提供的方法，而是我们自定义的一个可「挂起」的结果合并方法。至于挂起具体是什么，可以看下一篇文章。</p><p>让复杂的并发代码，写起来变得简单且清晰，是协程的优势。</p><p>这里，两个没有相关性的后台任务，因为用了协程，被安排得明明白白，互相之间配合得很好，也就是我们之前说的「协作式任务」。</p><p>本来需要回调，现在直接没有回调了，这种从 1 到 0 的设计思想真的妙哉。</p><p>在了解了协程的作用和优势之后，我们再来看看协程是怎么使用的。</p><h2 id="协程怎么用" tabindex="-1"><a class="header-anchor" href="#协程怎么用" aria-hidden="true">#</a> 协程怎么用</h2><h3 id="在项目中配置对-kotlin-协程的支持" tabindex="-1"><a class="header-anchor" href="#在项目中配置对-kotlin-协程的支持" aria-hidden="true">#</a> 在项目中配置对 Kotlin 协程的支持</h3><p>在使用协程之前，我们需要在 <code>build.gradle</code> 文件中增加对 Kotlin 协程的依赖：</p><ul><li>项目根目录下的 <code>build.gradle</code> :</li></ul><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>buildscript <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token comment">// 👇</span>
    ext<span class="token punctuation">.</span>kotlin_coroutines <span class="token operator">=</span> &#39;<span class="token number">1.3</span><span class="token punctuation">.</span><span class="token number">1</span>&#39;
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Module 下的 <code>build.gradle</code> :</li></ul><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>dependencies <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token comment">//                                       👇 依赖协程核心库</span>
    implementation <span class="token string-literal singleline"><span class="token string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">kotlin_coroutines</span></span><span class="token string">&quot;</span></span>
    <span class="token comment">//                                       👇 依赖当前平台所对应的平台库</span>
    implementation <span class="token string-literal singleline"><span class="token string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">kotlin_coroutines</span></span><span class="token string">&quot;</span></span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Kotlin 协程是以官方扩展库的形式进行支持的。而且，我们所使用的「核心库」和 「平台库」的版本应该保持一致。</p><ul><li>核心库中包含的代码主要是协程的公共 API 部分。有了这一层公共代码，才使得协程在各个平台上的接口得到统一。</li><li>平台库中包含的代码主要是协程框架在具体平台的具体实现方式。因为多线程在各个平台的实现方式是有所差异的。</li></ul><p>完成了以上的准备工作就可以开始使用协程了。</p><h3 id="开始使用协程" tabindex="-1"><a class="header-anchor" href="#开始使用协程" aria-hidden="true">#</a> 开始使用协程</h3><p>协程最简单的使用方法，其实在前面章节就已经看到了。我们可以通过一个 <code>launch</code> 函数实现线程切换的功能：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token comment">//               👇</span>
coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 <code>launch</code> 函数，它具体的含义是：我要创建一个新的协程，并在指定的线程上运行它。这个被创建、被运行的所谓「协程」是谁？就是你传给 <code>launch</code> 的那些代码，这一段连续代码叫做一个「协程」。</p><p>所以，什么时候用协程？当你需要切线程或者指定线程的时候。你要在后台执行任务？切！</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> image <span class="token operator">=</span> <span class="token function">getImage</span><span class="token punctuation">(</span>imageId<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后需要在前台更新界面？再切！</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> image <span class="token operator">=</span> <span class="token function">getImage</span><span class="token punctuation">(</span>imageId<span class="token punctuation">)</span>
    <span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        avatarIv<span class="token punctuation">.</span><span class="token function">setImageBitmap</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好像有点不对劲？这不还是有嵌套嘛。</p><p>如果只是使用 <code>launch</code> 函数，协程并不能比线程做更多的事。不过协程中却有一个很实用的函数：<code>withContext</code> 。这个函数可以切换到指定的线程，并在闭包内的逻辑执行结束之后，自动把线程切回去继续执行。那么可以将上面的代码写成这样：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 👈 在 UI 线程开始</span>
    <span class="token keyword">val</span> image <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 👈 切换到 IO 线程，并在执行完成后切回 UI 线程</span>
        <span class="token function">getImage</span><span class="token punctuation">(</span>imageId<span class="token punctuation">)</span>                      <span class="token comment">// 👈 将会运行在 IO 线程</span>
    <span class="token punctuation">}</span>
    avatarIv<span class="token punctuation">.</span><span class="token function">setImageBitmap</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span>             <span class="token comment">// 👈 回到 UI 线程更新 UI</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种写法看上去好像和刚才那种区别不大，但如果你需要频繁地进行线程切换，这种写法的优势就会体现出来。可以参考下面的对比：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token comment">// 第一种写法</span>
coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token operator">..</span><span class="token punctuation">.</span>
        <span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">..</span><span class="token punctuation">.</span>
            <span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token operator">..</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 通过第二种写法来实现相同的逻辑</span>
coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于可以&quot;自动切回来&quot;，消除了并发代码在协作时的嵌套。由于消除了嵌套关系，我们甚至可以把 <code>withContext</code> 放进一个单独的函数里面：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment">// 👈 在 UI 线程开始</span>
    <span class="token keyword">val</span> image <span class="token operator">=</span> <span class="token function">getImage</span><span class="token punctuation">(</span>imageId<span class="token punctuation">)</span>
    avatarIv<span class="token punctuation">.</span><span class="token function">setImageBitmap</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span>     <span class="token comment">// 👈 执行结束后，自动切换回 UI 线程</span>
<span class="token punctuation">}</span>
<span class="token comment">//                               👇</span>
<span class="token keyword">fun</span> <span class="token function">getImage</span><span class="token punctuation">(</span>imageId<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就是之前说的「用同步的方式写异步的代码」了。</p><p>不过如果只是这样写，编译器是会报错的：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">fun</span> <span class="token function">getImage</span><span class="token punctuation">(</span>imageId<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// IDE 报错 Suspend function&#39;withContext&#39; should be called only from a coroutine or another suspend funcion</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>意思是说，<code>withContext</code> 是一个 <code>suspend</code> 函数，它需要在协程或者是另一个 <code>suspend</code> 函数中调用。</p><h2 id="suspend" tabindex="-1"><a class="header-anchor" href="#suspend" aria-hidden="true">#</a> suspend</h2><p><code>suspend</code> 是 Kotlin 协程最核心的关键字，几乎所有介绍 Kotlin 协程的文章和演讲都会提到它。它的中文意思是「暂停」或者「可挂起」。如果你去看一些技术博客或官方文档的时候，大概可以了解到：「代码执行到 <code>suspend</code> 函数的时候会『挂起』，并且这个『挂起』是非阻塞式的，它不会阻塞你当前的线程。」</p><p>上面报错的代码，其实只需要在前面加一个 <code>suspend</code> 就能够编译通过：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token comment">//👇</span>
<span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">getImage</span><span class="token punctuation">(</span>imageId<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本篇文章到此结束，而 <code>suspend</code> 具体是什么，「非阻塞式」又是怎么回事，函数怎么被挂起，这些疑问的答案，将在下一篇文章全部揭晓。</p>`,65),_={href:"https://rengwuxian.com/kotlin-coroutines-1/",target:"_blank",rel:"noopener noreferrer"};function T(C,A){const a=o("ExternalLinkIcon");return c(),i("div",null,[u,d,r,k,v,n("p",null,[s("「协程 Coroutines」源自 Simula 和 Modula-2 语言，这个术语早在 1958 年就被 "),n("a",m,[s("Melvin Edward Conway"),e(a)]),s(" 发明并用于构建汇编程序，说明"),b,s("，并不局限于特定的语言。")]),g,n("p",null,[s("在这里需要一个类型为 "),h,s(" 的参数，而 "),f,s(" 是一个接口，且只定义了一个函数 "),x,s("，这种情况满足了 Kotlin 的 "),n("a",I,[s("SAM"),e(a)]),s("，可以转换成传递一个 lambda 表达式（第二段），因为是最后一个参数，根据闭包原则我们就可以直接写成 "),w,s("（第三段） 的形式。")]),y,n("p",null,[s("本文转自 "),n("a",_,[s("https://rengwuxian.com/kotlin-coroutines-1/"),e(a)]),s("，如有侵权，请联系删除。")])])}const D=p(l,[["render",T],["__file","Kotlindexiechengyonglipieyiyan.html.vue"]]);export{D as default};
