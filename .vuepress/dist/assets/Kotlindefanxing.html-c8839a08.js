import{_ as e,r as t,o as p,c as o,b as s,d as n,e as c,a as l}from"./app-e8f85126.js";const i={},d=l(`<h2 id="从-kotlin-的-in-和-out-说起" tabindex="-1"><a class="header-anchor" href="#从-kotlin-的-in-和-out-说起" aria-hidden="true">#</a> 从 Kotlin 的 in 和 out 说起</h2><p>提到 Kotlin 的泛型，通常离不开 <code>in</code> 和 <code>out</code> 关键字，但泛型这门武功需要些基本功才能修炼，否则容易走火入魔，待笔者慢慢道来。</p><p>下面这段 Java 代码在日常开发中应该很常见了：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span> textViews <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>List&lt;TextView&gt;</code> 表示这是一个泛型类型为 <code>TextView</code> 的 <code>List</code>。</p><p>那到底什么是泛型呢？我们先来讲讲泛型的由来。</p><p>现在的程序开发大都是面向对象的，平时会用到各种类型的对象，一组对象通常需要用集合来存储它们，因而就有了一些集合类，比如 <code>List</code>、<code>Map</code> 等。</p><p>这些集合类里面都是装的具体类型的对象，如果每个类型都去实现诸如 <code>TextViewList</code>、<code>ActivityList</code> 这样的具体的类型，显然是不可能的。</p><p>因此就诞生了「泛型」，它的意思是把具体的类型泛化，编码的时候用符号来指代类型，在使用的时候，再确定它的类型。</p><p>前面那个例子，<code>List&lt;TextView&gt;</code> 就是泛型类型声明。</p><p>既然泛型是跟类型相关的，那么是不是也能适用类型的多态呢？</p><p>先看一个常见的使用场景：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">TextView</span> textView <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Button</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 👆 这是多态</span>

<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span> buttons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span> textViews <span class="token operator">=</span> buttons<span class="token punctuation">;</span>
<span class="token comment">// 👆 多态用在这里会报错 incompatible types: List&lt;Button&gt; cannot be converted to List&lt;TextView&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们知道 <code>Button</code> 是继承自 <code>TextView</code> 的，根据 Java 多态的特性，第一处赋值是正确的。</p><p>但是到了 <code>List&lt;TextView&gt;</code> 的时候 IDE 就报错了，这是因为 Java 的泛型本身具有「不可变性 Invariance」，Java 里面认为 <code>List&lt;TextView&gt;</code> 和 <code>List&lt;Button&gt;</code> 类型并不一致，也就是说，子类的泛型（<code>List&lt;Button&gt;</code>）不属于泛型（<code>List&lt;TextView&gt;</code>）的子类。</p><blockquote><p>Java 的泛型类型会在编译时发生<strong>类型擦除</strong>，为了保证类型安全，不允许这样赋值。至于什么是类型擦除，这里就不展开了。</p><p>你可以试一下，在 Java 里用数组做类似的事情，是不会报错的，这是因为数组并没有在编译时擦除类型：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> ☕️
 <span class="token class-name">TextView</span><span class="token punctuation">[</span><span class="token punctuation">]</span> textViews <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TextView</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>但是在实际使用中，我们的确会有这种类似的需求，需要实现上面这种赋值。</p><p>Java 提供了「泛型通配符」 <code>? extends</code> 和 <code>? super</code> 来解决这个问题。</p><h2 id="java-中的-extends" tabindex="-1"><a class="header-anchor" href="#java-中的-extends" aria-hidden="true">#</a> Java 中的 <code>? extends</code></h2><p>在 Java 里面是这么解决的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span> buttons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      👇
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span> textViews <span class="token operator">=</span> buttons<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 <code>? extends</code> 叫做「上界通配符」，可以使 Java 泛型具有「协变性 Covariance」，协变就是允许上面的赋值是合法的。</p><blockquote><p>在继承关系树中，子类继承自父类，可以认为父类在上，子类在下。<code>extends</code> 限制了泛型类型的父类型，所以叫上界。</p></blockquote><p>它有两层意思：</p><ul><li>其中 <code>?</code> 是个通配符，表示这个 <code>List</code> 的泛型类型是一个<strong>未知类型</strong>。</li><li><code>extends</code> 限制了这个未知类型的上界，也就是泛型类型必须满足这个 <code>extends</code> 的限制条件，这里和定义 <code>class</code> 的 <code>extends</code> 关键字有点不一样： <ul><li>它的范围不仅是所有直接和间接子类，还包括上界定义的父类本身，也就是 <code>TextView</code>。</li><li>它还有 <code>implements</code> 的意思，即这里的上界也可以是 <code>interface</code>。</li></ul></li></ul><p>这里 <code>Button</code> 是 <code>TextView</code> 的子类，满足了泛型类型的限制条件，因而能够成功赋值。</p><p>根据刚才的描述，下面几种情况都是可以的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span> textViews <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 👈 本身</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span> textViews <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 👈 直接子类</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span> textViews <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RadioButton</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 👈 间接子类</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般集合类都包含了 <code>get</code> 和 <code>add</code> 两种操作，比如 Java 中的 <code>List</code>，它的具体定义如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码中，<code>E</code> 就是表示泛型类型的符号（用其他字母甚至单词都可以）。</p><p>我们看看在使用了上界通配符之后，<code>List</code> 的使用上有没有什么问题：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span> textViews <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">TextView</span> textView <span class="token operator">=</span> textViews<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 👈 get 可以</span>
textViews<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>textView<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//             👆 add 会报错，no suitable method found for add(TextView)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面说到 <code>List&lt;? extends TextView&gt;</code> 的泛型类型是个未知类型 <code>?</code>，编译器也不确定它是啥类型，只是有个限制条件。</p><p>由于它满足 <code>? extends TextView</code> 的限制条件，所以 <code>get</code> 出来的对象，肯定是 <code>TextView</code> 的子类型，根据多态的特性，能够赋值给 <code>TextView</code>，啰嗦一句，赋值给 <code>View</code> 也是没问题的。</p><p>到了 <code>add</code> 操作的时候，我们可以这么理解：</p><ul><li><code>List&lt;? extends TextView&gt;</code> 由于类型未知，它可能是 <code>List&lt;Button&gt;</code>，也可能是 <code>List&lt;TextView&gt;</code>。</li><li>对于前者，显然我们要添加 TextView 是不可以的。</li><li>实际情况是编译器无法确定到底属于哪一种，无法继续执行下去，就报错了。</li></ul><p>那我干脆不要 <code>extends TextView</code> ，只用通配符 <code>?</code> 呢？</p><p>这样使用 <code>List&lt;?&gt;</code> 其实是 <code>List&lt;? extends Object&gt;</code> 的缩写。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span> buttons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> buttons<span class="token punctuation">;</span>
<span class="token class-name">Object</span> obj <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 👈 这里还是会报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和前面的例子一样，编译器没法确定 <code>?</code> 的类型，所以这里就只能 <code>get</code> 到 <code>Object</code> 对象。</p><p>同时编译器为了保证类型安全，也不能向 <code>List&lt;?&gt;</code> 中添加任何类型的对象，理由同上。</p><p>由于 <code>add</code> 的这个限制，使用了 <code>? extends</code> 泛型通配符的 <code>List</code>，只能够向外提供数据被消费，从这个角度来讲，向外提供数据的一方称为「生产者 Producer」。对应的还有一个概念叫「消费者 Consumer」，对应 Java 里面另一个泛型通配符 <code>? super</code>。</p><h2 id="java-中的-super" tabindex="-1"><a class="header-anchor" href="#java-中的-super" aria-hidden="true">#</a> Java 中的 <code>? super</code></h2><p>先看一下它的写法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
     👇
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span> buttons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 <code>? super</code> 叫做「下界通配符」，可以使 Java 泛型具有「逆变性 Contravariance」。</p><blockquote><p>与上界通配符对应，这里 super 限制了通配符 ? 的子类型，所以称之为下界。</p></blockquote><p>它也有两层意思：</p><ul><li>通配符 <code>?</code> 表示 <code>List</code> 的泛型类型是一个<strong>未知类型</strong>。</li><li><code>super</code> 限制了这个未知类型的下界，也就是泛型类型必须满足这个 <code>super</code> 的限制条件。 <ul><li><code>super</code> 我们在类的方法里面经常用到，这里的范围不仅包括 <code>Button</code> 的直接和间接父类，也包括下界 <code>Button</code> 本身。</li><li><code>super</code> 同样支持 <code>interface</code>。</li></ul></li></ul><p>上面的例子中，<code>TextView</code> 是 <code>Button</code> 的父类型 ，也就能够满足 <code>super</code> 的限制条件，就可以成功赋值了。</p><p>根据刚才的描述，下面几种情况都是可以的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span> buttons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 👈 本身</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span> buttons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 👈 直接父类</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span> buttons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 👈 间接父类</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于使用了下界通配符的 <code>List</code>，我们再看看它的 <code>get</code> 和 <code>add</code> 操作：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Button</span><span class="token punctuation">&gt;</span></span> buttons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TextView</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> object <span class="token operator">=</span> buttons<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 👈 get 出来的是 Object 类型</span>
<span class="token class-name">Button</span> button <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
buttons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>button<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 👈 add 操作是可以的</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释下，首先 <code>?</code> 表示未知类型，编译器是不确定它的类型的。</p><p>虽然不知道它的具体类型，不过在 Java 里任何对象都是 <code>Object</code> 的子类，所以这里能把它赋值给 <code>Object</code>。</p><p><code>Button</code> 对象一定是这个未知类型的子类型，根据多态的特性，这里通过 <code>add</code> 添加 <code>Button</code> 对象是合法的。</p><p>使用下界通配符 <code>? super</code> 的泛型 <code>List</code>，只能读取到 <code>Object</code> 对象，一般没有什么实际的使用场景，通常也只拿它来添加数据，也就是消费已有的 <code>List&lt;? super Button&gt;</code>，往里面添加 <code>Button</code>，因此这种泛型类型声明称之为「消费者 Consumer」。</p><hr><p>小结下，Java 的泛型本身是不支持协变和逆变的。</p><ul><li>可以使用泛型通配符 <code>? extends</code> 来使泛型支持协变，但是「只能读取不能修改」，这里的修改仅指对泛型集合添加元素，如果是 <code>remove(int index)</code> 以及 <code>clear</code> 当然是可以的。</li><li>可以使用泛型通配符 <code>? super</code> 来使泛型支持逆变，但是「只能修改不能读取」，这里说的不能读取是指不能按照泛型类型读取，你如果按照 <code>Object</code> 读出来再强转当然也是可以的。</li></ul><p>根据前面的说法，这被称为 PECS 法则：「<em>Producer-Extends, Consumer-Super</em>」。</p><p>理解了 Java 的泛型之后，再理解 Kotlin 中的泛型，有如练完九阳神功再练乾坤大挪移，就比较容易了。</p><h2 id="说回-kotlin-中的-out-和-in" tabindex="-1"><a class="header-anchor" href="#说回-kotlin-中的-out-和-in" aria-hidden="true">#</a> 说回 Kotlin 中的 <code>out</code> 和 <code>in</code></h2><p>和 Java 泛型一样，Kolin 中的泛型本身也是不可变的。</p><ul><li>使用关键字 <code>out</code> 来支持协变，等同于 Java 中的上界通配符 <code>? extends</code>。</li><li>使用关键字 <code>in</code> 来支持逆变，等同于 Java 中的下界通配符 <code>? super</code>。</li></ul><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">var</span> textViews<span class="token operator">:</span> List<span class="token operator">&lt;</span><span class="token keyword">out</span> TextView<span class="token operator">&gt;</span>
<span class="token keyword">var</span> textViews<span class="token operator">:</span> List<span class="token operator">&lt;</span><span class="token keyword">in</span> TextView<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>换了个写法，但作用是完全一样的。<code>out</code> 表示，我这个变量或者参数只用来输出，不用来输入，你只能读我不能写我；<code>in</code> 就反过来，表示它只用来输入，不用来输出，你只能写我不能读我。</p><p>你看，我们 Android 工程师学不会 <code>out</code> 和 <code>in</code>，其实并不是因为这两个关键字多难，而是因为我们应该先学学 Java 的泛型。是吧？</p><p>说了这么多 <code>List</code>，其实泛型在非集合类的使用也非常广泛，就以「生产者-消费者」为例子：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> Producer<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token punctuation">{</span>
        <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">val</span> producer<span class="token operator">:</span> Producer<span class="token operator">&lt;</span><span class="token keyword">out</span> TextView<span class="token operator">&gt;</span> <span class="token operator">=</span> Producer<span class="token operator">&lt;</span>Button<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> textView<span class="token operator">:</span> TextView <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 👈 相当于 &amp;#39;List&amp;#39; 的 \`get\`</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再来看看消费者：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️            
<span class="token keyword">class</span> Consumer<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">consume</span><span class="token punctuation">(</span>t<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">val</span> consumer<span class="token operator">:</span> Consumer<span class="token operator">&lt;</span><span class="token keyword">in</span> Button<span class="token operator">&gt;</span> <span class="token operator">=</span> Consumer<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
consumer<span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span><span class="token function">Button</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 👈 相当于 &amp;#39;List&amp;#39; 的 &amp;#39;add&amp;#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="声明处的-out-和-in" tabindex="-1"><a class="header-anchor" href="#声明处的-out-和-in" aria-hidden="true">#</a> 声明处的 <code>out</code> 和 <code>in</code></h2><p>在前面的例子中，在声明 <code>Producer</code> 的时候已经确定了泛型 <code>T</code> 只会作为输出来用，但是每次都需要在使用的时候加上 <code>out TextView</code> 来支持协变，写起来很麻烦。</p><p>Kotlin 提供了另外一种写法：可以在声明类的时候，给泛型符号加上 <code>out</code> 关键字，表明泛型参数 <code>T</code> 只会用来输出，在使用的时候就不用额外加 <code>out</code> 了。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️             👇
<span class="token keyword">class</span> Producer<span class="token operator">&lt;</span><span class="token keyword">out</span> T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token punctuation">{</span>
        <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">val</span> producer<span class="token operator">:</span> Producer<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span> <span class="token operator">=</span> Producer<span class="token operator">&lt;</span>Button<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 👈 这里不写 out 也不会报错</span>
<span class="token keyword">val</span> producer<span class="token operator">:</span> Producer<span class="token operator">&lt;</span><span class="token keyword">out</span> TextView<span class="token operator">&gt;</span> <span class="token operator">=</span> Producer<span class="token operator">&lt;</span>Button<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 👈 out 可以但没必要</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与 <code>out</code> 一样，可以在声明类的时候，给泛型参数加上 <code>in</code> 关键字，来表明这个泛型参数 <code>T</code> 只用来输入。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️            👇
<span class="token keyword">class</span> Consumer<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">consume</span><span class="token punctuation">(</span>t<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">val</span> consumer<span class="token operator">:</span> Consumer<span class="token operator">&lt;</span>Button<span class="token operator">&gt;</span> <span class="token operator">=</span> Consumer<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 👈 这里不写 in 也不会报错</span>
<span class="token keyword">val</span> consumer<span class="token operator">:</span> Consumer<span class="token operator">&lt;</span><span class="token keyword">in</span> Button<span class="token operator">&gt;</span> <span class="token operator">=</span> Consumer<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 👈 in 可以但没必要</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="号" tabindex="-1"><a class="header-anchor" href="#号" aria-hidden="true">#</a> <code>*</code> 号</h2><p>前面讲到了 Java 中单个 <code>?</code> 号也能作为泛型通配符使用，相当于 <code>? extends Object</code>。<br> 它在 Kotlin 中有等效的写法：<code>*</code> 号，相当于 <code>out Any</code>。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️            👇
<span class="token keyword">var</span> list<span class="token operator">:</span> List<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>和 Java 不同的地方是，如果你的类型定义里已经有了 <code>out</code> 或者 <code>in</code>，那这个限制在变量声明时也依然在，不会被 <code>*</code> 号去掉。</p><p>比如你的类型定义里是 <code>out T : Number</code> 的，那它加上 <code>&lt;*&gt;</code> 之后的效果就不是 <code>out Any</code>，而是 <code>out Number</code>。</p><h2 id="where-关键字" tabindex="-1"><a class="header-anchor" href="#where-关键字" aria-hidden="true">#</a> <code>where</code> 关键字</h2><p>Java 中声明类或接口的时候，可以使用 <code>extends</code> 来设置边界，将泛型类型参数限制为某个类型的子集：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️                
<span class="token comment">//                👇  T 的类型必须是 Animal 的子类型</span>
<span class="token keyword">class</span> <span class="token class-name">Monster</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这个和前面讲的声明变量时的泛型类型声明是不同的东西，这里并没有 <code>?</code>。</p><p>同时这个边界是可以设置多个，用 <code>&amp;</code> 符号连接：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token comment">//                            👇  T 的类型必须同时是 Animal 和 Food 的子类型</span>
<span class="token keyword">class</span> <span class="token class-name">Monster</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token operator">&amp;</span> <span class="token class-name">Food</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Kotlin 只是把 <code>extends</code> 换成了 <code>:</code> 冒号。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️             👇
<span class="token keyword">class</span> Monster<span class="token operator">&lt;</span>T <span class="token operator">:</span> Animal<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>设置多个边界可以使用 <code>where</code> 关键字：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️                👇
<span class="token keyword">class</span> Monster<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword">where</span> T <span class="token operator">:</span> Animal<span class="token punctuation">,</span> T <span class="token operator">:</span> Food
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>有人在看文档的时候觉得这个 <code>where</code> 是个新东西，其实虽然 Java 里没有 <code>where</code> ，但它并没有带来新功能，只是把一个老功能换了个新写法。</p><p>不过笔者觉得 Kotlin 里 <code>where</code> 这样的写法可读性更符合英文里的语法，尤其是如果 <code>Monster</code> 本身还有继承的时候：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️
<span class="token keyword">class</span> Monster<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">:</span> MonsterParent<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>
    <span class="token keyword">where</span> T <span class="token operator">:</span> Animal
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="reified-关键字" tabindex="-1"><a class="header-anchor" href="#reified-关键字" aria-hidden="true">#</a> <code>reified</code> 关键字</h2><p>由于 Java 中的泛型存在类型擦除的情况，任何在运行时需要知道泛型确切类型信息的操作都没法用了。</p><p>比如你不能检查一个对象是否为泛型类型 <code>T</code> 的实例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️
<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">printIfTypeMatch</span><span class="token punctuation">(</span><span class="token class-name">Object</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token keyword">instanceof</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 👈 IDE 会提示错误，illegal generic type for instanceof</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Kotlin 里同样也不行：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>🏝️
fun <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">printIfTypeMatch</span><span class="token punctuation">(</span>item<span class="token operator">:</span> <span class="token class-name">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>item is <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 👈 IDE 会提示错误，Cannot check for instance of erased type: T</span>
        <span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个问题，在 Java 中的解决方案通常是额外传递一个 <code>Class&lt;T&gt;</code> 类型的参数，然后通过 <code>Class#isInstance</code> 方法来检查：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>☕️                             👇
<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token class-name">Object</span> item<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               👆
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Kotlin 中同样可以这么解决，不过还有一个更方便的做法：使用关键字 <code>reified</code> 配合 <code>inline</code> 来解决：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>🏝️ 👇         👇
<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> T<span class="token operator">&gt;</span> <span class="token function">printIfTypeMatch</span><span class="token punctuation">(</span>item<span class="token operator">:</span> Any<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token keyword">is</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 👈 这里就不会在提示错误了</span>
        <span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这具体是怎么回事呢？等到后续章节讲到 <code>inline</code> 的时候会详细说明，这里就不过多延伸了。</p><p>还记得第二篇文章中，提到了两个 Kotlin 泛型与 Java 泛型不一致的地方，这里作一下解答。</p><ol><li><p>Java 里的数组是支持协变的，而 Kotlin 中的数组 <code>Array</code> 不支持协变。</p><p>这是因为在 Kotlin 中数组是用 <code>Array</code> 类来表示的，这个 <code>Array</code> 类使用泛型就和集合类一样，所以不支持协变。</p></li><li><p>Java 中的 <code>List</code> 接口不支持协变，而 Kotlin 中的 <code>List</code> 接口支持协变。</p><p>Java 中的 <code>List</code> 不支持协变，原因在上文已经讲过了，需要使用泛型通配符来解决。</p><p>在 Kotlin 中，实际上 <code>MutableList</code> 接口才相当于 Java 的 <code>List</code>。Kotlin 中的 <code>List</code> 接口实现了只读操作，没有写操作，所以不会有类型安全上的问题，自然可以支持协变。</p></li></ol>`,111),u={href:"https://rengwuxian.com/kotlin-generics/",target:"_blank",rel:"noopener noreferrer"};function r(k,v){const a=t("ExternalLinkIcon");return p(),o("div",null,[d,s("p",null,[n("本文转自 "),s("a",u,[n("https://rengwuxian.com/kotlin-generics/"),c(a)]),n("，如有侵权，请联系删除。")])])}const g=e(i,[["render",r],["__file","Kotlindefanxing.html.vue"]]);export{g as default};
