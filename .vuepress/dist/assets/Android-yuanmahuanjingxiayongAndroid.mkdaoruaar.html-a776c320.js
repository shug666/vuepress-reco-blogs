import{_ as i,r as l,o,c as r,b as a,d as n,e as s,a as t}from"./app-e8f85126.js";const p={},d=t(`<p>本文讨论两个问题：</p><ol><li>如何在Android 源码环境下使用Android.mk 的方式把aar 导入apk（apk 引用aar 的内容）；</li><li>含有so 文件的aar 在源码环境下编译后so 文件不会被打包进apk，如何解决app 运行时找不到so 的问题。</li></ol><p>现在新的源码中很多app 已经切换到了Android.bp，不过目前Android.mk 还是兼容的。下面介绍在Android.mk 中导入aar 包</p><h2 id="在android-mk-中导入aar-包" tabindex="-1"><a class="header-anchor" href="#在android-mk-中导入aar-包" aria-hidden="true">#</a> 在Android.mk 中导入aar 包</h2><p>第一步：先声明 aar 包的位置</p><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code><span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>CLEAR_VARS<span class="token punctuation">)</span>
LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES <span class="token operator">+=</span> aar_alias<span class="token punctuation">:</span>libs/aar-release_1.0.aar
<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_MULTI_PREBUILT<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的代码整段都需要，而不只是中间那一行。</p><p>第二步：引用我们声明的 aar 变量</p><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code>LOCAL_STATIC_JAVA_AAR_LIBRARIES <span class="token operator">:=</span> aar_alias
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第三步：添加引用的 aar 包里面的资源</p><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code>LOCAL_AAPT_FLAGS <span class="token operator">+=</span> \\
         --auto-add-overlay \\
         --extra-packages com.example.aar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>com.example.aar 为aar 的包名。</p><p>第二步和第三步是添加到apk 的 include $(CLEAR_VARS) 和include $(CLEAR_VARS) 中间。</p><hr><h2 id="运行时找不到so-aar-里的so" tabindex="-1"><a class="header-anchor" href="#运行时找不到so-aar-里的so" aria-hidden="true">#</a> 运行时找不到so（aar 里的so）</h2><p>如果aar 中含有so 文件的话，通常使用Android Studio 构建apk 的话，so 会打包到apk的lib 目录下（解压后可以查看到），而在源码下使用Android.mk 的方式编译的话，编译出的apk 是不含so 文件的，也就意味着如果你adb install 编译出来的apk，它是不能按预期运行的。</p><p>两种方法解决这个问题</p><h3 id="方案一-预置apk-预置aar-里的so-到-system-lib64-目录" tabindex="-1"><a class="header-anchor" href="#方案一-预置apk-预置aar-里的so-到-system-lib64-目录" aria-hidden="true">#</a> 方案一 预置apk + 预置aar 里的so 到/system/lib64/ 目录</h3><p>使用Android.mk 的方式在源码下编译，大概率也是要预置这个apk 了，可以在编译apk 的mk 文件中增加预置so 文件的代码。当然，首先要把aar 里的so 文件解压出来（集成交付可能不太友好，除了更新aar 还要再一次把aar 里的so 解压出来）。</p><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code><span class="token comment">#  jni so</span>
<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>CLEAR_VARS<span class="token punctuation">)</span>
LOCAL_MODULE <span class="token operator">:=</span> libGet_Point-jni
LOCAL_MODULE_TAGS <span class="token operator">:=</span> optional
LOCAL_SRC_FILES <span class="token operator">:=</span> libs/<span class="token variable">$</span><span class="token punctuation">(</span>LOCAL_MODULE<span class="token punctuation">)</span>.so
LOCAL_MODULE_STEM <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>LOCAL_MODULE<span class="token punctuation">)</span>
LOCAL_MODULE_SUFFIX <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">suffix</span> <span class="token variable">$</span><span class="token punctuation">(</span>LOCAL_SRC_FILES<span class="token punctuation">)</span><span class="token punctuation">)</span>
LOCAL_SHARED_LIBRARIES <span class="token operator">:=</span> liblog libxt_get_point
LOCAL_MODULE_CLASS <span class="token operator">:=</span> SHARED_LIBRARIES
LOCAL_MULTILIB <span class="token operator">:=</span> 64
<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_PREBUILT<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不要忘了app 依赖的代码</p><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code><span class="token comment"># jni so</span>
LOCAL_JNI_SHARED_LIBRARIES <span class="token operator">:=</span> libGet_Point-jni
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>so 文件将会被编译预置到/system/lib64/ 目录下，将apk push 到/system/app/AarTest/ 目录下验证可以运行。</p><p>注意，so 放到 /vendor/lib64/ 下面访问不到（估计需要app 编译声明为VENDOR app），如果app 是install 安装的，那也没有权限访问/system/lib64/ 下面的so</p><h3 id="方案二-将aar-中的so-打包进apk-未成功" tabindex="-1"><a class="header-anchor" href="#方案二-将aar-中的so-打包进apk-未成功" aria-hidden="true">#</a> 方案二 将aar 中的so 打包进apk？(未成功)</h3><p>按照网上文章说的，添加 LOCAL_JNI_SHARED_LIBRARIES := libGet_Point-jni 后so 会自动打包进so，然而实测并没有；</p><p>预置so 文件的make 代码写法出了上面列出的一种以外，还搜到一个</p><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code>LOCAL_PREBUILT_LIBS <span class="token operator">:=</span> libGet_Point-jni<span class="token punctuation">:</span>libs/libGet_Point-jni.so
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是假如这个so 还依赖其他so 的话就会编译不过（回头看上面第一种，LOCAL_SHARED_LIBRARIES := liblog 还依赖了liblog）。同样的，假如上面的代码不会导致编译错误，也还需要</p><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code><span class="token comment"># jni so</span>
LOCAL_JNI_SHARED_LIBRARIES <span class="token operator">:=</span> libGet_Point-jni
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不写这一行也能push apk 成功运行，但是编译出来apk 目录下没有 lib 软链<br> 添加了 LOCAL_JNI_SHARED_LIBRARIES 之后编译出出的apk 目录下有lib 软链，apk 本身是不含so 文件的</p><p><strong>so 打包进apk 失败</strong></p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2>`,33),c={href:"https://blog.csdn.net/alexchen840131/article/details/84928154",target:"_blank",rel:"noopener noreferrer"},u={href:"https://blog.csdn.net/qq_27788177/article/details/103719570",target:"_blank",rel:"noopener noreferrer"},k={href:"https://blog.csdn.net/wd229047557/article/details/96141623",target:"_blank",rel:"noopener noreferrer"},_={href:"https://blog.csdn.net/tkwxty/article/details/17039145",target:"_blank",rel:"noopener noreferrer"},m={href:"https://blog.csdn.net/petib_wangwei/article/details/72844515",target:"_blank",rel:"noopener noreferrer"},b={href:"https://blog.csdn.net/u012932409/article/details/108119443",target:"_blank",rel:"noopener noreferrer"},v={href:"https://blog.csdn.net/aaa111/article/details/125328879",target:"_blank",rel:"noopener noreferrer"};function A(L,h){const e=l("ExternalLinkIcon");return o(),r("div",null,[d,a("ol",null,[a("li",null,[a("a",c,[n("Android 程序开发 总结一： 源码编译引用包含so文件的AAR文件_alexchen840131的博客-CSDN博客"),s(e)])]),a("li",null,[a("a",u,[n("【安卓开发系列 – 系统开发】AOSP 源码环境开发系统 APP 预置带有 SO 的 AAR 包_奋斗企鹅CopperSun的博客-CSDN博客_libpl_droidsonroids_gif.so"),s(e)])]),a("li",null,[a("a",k,[n("Android源码 app预制带so和assets文件的aar包(sdk)_wd623894174的博客-CSDN博客"),s(e)])]),a("li",null,[a("a",_,[n("Android打包so文件到apk_IT先森的博客-CSDN博客"),s(e)])]),a("li",null,[a("a",m,[n("在Android源码中如何吧so库打包编译进入apk， 集成第三方库（jar和so库）_WangMark的博客-CSDN博客"),s(e)])]),a("li",null,[a("a",b,[n("Android.bp 文件中引入aar、jar、so库正确编译方法(值得收藏)_cczhengv的博客-CSDN博客_android.bp 编译jar"),s(e)])])]),a("p",null,[n("本文转自 "),a("a",v,[n("https://blog.csdn.net/aaa111/article/details/125328879"),s(e)]),n("，如有侵权，请联系删除。")])])}const f=i(p,[["render",A],["__file","Android-yuanmahuanjingxiayongAndroid.mkdaoruaar.html.vue"]]);export{f as default};
