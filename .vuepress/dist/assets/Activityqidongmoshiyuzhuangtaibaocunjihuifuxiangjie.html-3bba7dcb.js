import{_ as e,r as i,o as c,c as o,b as n,d as a,e as s,a as p}from"./app-f541e591.js";const r={},l=n("h2",{id:"一-简介",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#一-简介","aria-hidden":"true"},"#"),a(" 一.简介")],-1),d={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FAndroid%25E7%25BB%2584%25E4%25BB%25B6%2F10446728",target:"_blank",rel:"noopener noreferrer"},u={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E7%25BB%2584%25E4%25BB%25B6",target:"_blank",rel:"noopener noreferrer"},v={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%25B1%258F%25E5%25B9%2595%2F3750314",target:"_blank",rel:"noopener noreferrer"},k=n("p",null,[a("Activity中所有操作都与用户密切相关，是一个负责与"),n("strong",null,"用户交互"),a("的组件，可以通过setContentView(View)来"),n("strong",null,"显示指定控件"),a("。")],-1),h=n("p",null,"在一个android应用中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。Activity之间通过Intent进行通信。",-1),y={href:"https://www.jianshu.com/p/52276d5a979c",target:"_blank",rel:"noopener noreferrer"},m=p(`<h2 id="二-启动模式" tabindex="-1"><a class="header-anchor" href="#二-启动模式" aria-hidden="true">#</a> 二.启动模式</h2><p>activity有四种启动模式，分别为standard，singleTop，singleTask，singleInstance。如果要使用这四种启动模式，必须在manifest文件中activity标签中的launchMode属性中配置。</p><h3 id="a-standard" tabindex="-1"><a class="header-anchor" href="#a-standard" aria-hidden="true">#</a> a.standard</h3><p>标准的默认启动模式，这种模式下activity可以被多次实例化，即在一个task中可以存在多个activity，每一个activity会处理一个intent对象，（在A中再次启动A，会存在后面的A在前面的A上面，当前task会存在两个activity的实例对象）</p><h3 id="b-singletop" tabindex="-1"><a class="header-anchor" href="#b-singletop" aria-hidden="true">#</a> b.singleTop</h3><p>如果一个singleTop模式启动的activity实例已经存在于栈顶，那么再次启动这个activity的时候，不会重新创建实例，而是重用位于栈顶的那个实例，并且会调用实例的onNewIntent()方法将Intent对象传递到这个实例中，如果实例不位于栈顶，会创建新的实例。</p><h3 id="c-singletask" tabindex="-1"><a class="header-anchor" href="#c-singletask" aria-hidden="true">#</a> c.singleTask:</h3><p>启动模式设置为singleTask，framework在启动该activity时只会把它标示为可在一个新任务中启动，至于是否在一个新任务中启动，还要受其他条件的限制，即taskAffinity属性。</p><p><strong>taskAffinity</strong>：默认情况下，一个应用中的所有activity具有相同的taskAffinity，即应用程序的包名。我们可以通过设置不同的taskAffinity属性给应用中的activity分组，也可以把不同的应用中的activity的taskAffinity设置成相同的值，当两个不同应用中的activity设置成相同的taskAffinity时，则两个activity会属于同一个TaskRecord。</p><p>在启动一个singleTask的Activity实例时，如果系统中已经存在这样一个实例，就会将这个实例调度到任务栈的栈顶，并清除它当前所在任务中位于它上面的所有的activity；如果这个已存在的任务中不存在一个要启动的Activity的实例，则在这个任务的顶端启动一个实例；若这个任务不存在，则会启动一个新的任务，在这个新的任务中启动这个singleTask模式的Activity的一个实例。</p><h3 id="d-singleinstance" tabindex="-1"><a class="header-anchor" href="#d-singleinstance" aria-hidden="true">#</a> d.singleInstance:</h3><p>以singleInstance模式启动的Activity具有全局唯一性，即整个系统中只会存在一个这样的实例，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</p><p>以singleInstance模式启动的Activity具有独占性，即它会独自占用一个任务，被他开启的任何activity都会运行在其他任务中（官方文档上的描述为，singleInstance模式的Activity不允许其他Activity和它共存在一个任务中）。</p><p>被singleInstance模式的Activity开启的其他activity，能够开启一个新任务，但不一定开启新的任务，也可能在已有的一个任务中开启，受条件的限制，这个条件是：当前系统中是不是已经有了一个activity B的taskAffinity属性指定的任务。</p><h4 id="三-activity管理" tabindex="-1"><a class="header-anchor" href="#三-activity管理" aria-hidden="true">#</a> 三.Activity管理</h4><p>涉及到Activity启动，就不得不说一下Activity的管理，Activity是以什么方式及被什么类来进行管理的，涉及的类主要如下：</p><h3 id="a-activityrecord" tabindex="-1"><a class="header-anchor" href="#a-activityrecord" aria-hidden="true">#</a> a.ActivityRecord：</h3><p>历史栈中的一个条目，代表一个activity。ActivityRecord中的成员变量task表示其所在的TaskRecord，ActivityRecord与TaskRecord建立了联系。</p><h3 id="b-taskrecord" tabindex="-1"><a class="header-anchor" href="#b-taskrecord" aria-hidden="true">#</a> b.TaskRecord：</h3><p>内部维护一个 <code>ArrayList&lt;ActivityRecord&gt;</code> 用来保存ActivityRecord，TaskRecord中的mStack表示其所在的ActivityStack，TaskRecord与ActivityStack建立了联系。</p><h3 id="c-activitystack" tabindex="-1"><a class="header-anchor" href="#c-activitystack" aria-hidden="true">#</a> c.ActivityStack：</h3><p>内部维护了一个 <code>ArrayList&lt;TaskRecord&gt;</code> ，用来管理TaskRecord，ActivityStack中持有ActivityStackSupervisor对象，由ActivityStackSupervisor创建。</p><h3 id="d-activitystacksupervisor" tabindex="-1"><a class="header-anchor" href="#d-activitystacksupervisor" aria-hidden="true">#</a> d.ActivityStackSupervisor：</h3><p>负责所有ActivityStack的管理。内部管理了mHomeStack、mFocusedStack和mLastFocusedStack三个Activity栈。其中，mHomeStack管理的是Launcher相关的Activity栈；mFocusedStack管理的是当前显示在前台Activity的Activity栈；mLastFocusedStack管理的是上一次显示在前台Activity的Activity栈。</p><h3 id="e-activitythread" tabindex="-1"><a class="header-anchor" href="#e-activitythread" aria-hidden="true">#</a> e.ActivityThread：</h3><p>ActivityThread 运行在UI线程（主线程），App的真正入口。</p><h3 id="f-applicationthread" tabindex="-1"><a class="header-anchor" href="#f-applicationthread" aria-hidden="true">#</a> f.ApplicationThread：</h3><p>用来实现AMS和ActivityThread之间的交互。</p><h3 id="g-instrumentation" tabindex="-1"><a class="header-anchor" href="#g-instrumentation" aria-hidden="true">#</a> g.Instrumentation：</h3><p>负责调用Activity和Application生命周期。</p><h2 id="四-activity状态保存" tabindex="-1"><a class="header-anchor" href="#四-activity状态保存" aria-hidden="true">#</a> 四.Activity状态保存</h2><p>当一个Activity未被主动关闭，即“被动关闭”时，可能需要系统给用户提供保持一些状态的入口。</p><h3 id="a-调用入口" tabindex="-1"><a class="header-anchor" href="#a-调用入口" aria-hidden="true">#</a> a.调用入口</h3><p>前面说的入口就是：Activity提供了onSaveInstanceState()方法，该方法是Activity在关闭前保存状态的核心方法。</p><h3 id="b-调用场景" tabindex="-1"><a class="header-anchor" href="#b-调用场景" aria-hidden="true">#</a> b.调用场景</h3><p>前面提到“被动关闭”，如果是主动关闭那么就不会调用，比如：按back键、调用finish()等，那么&quot;被动关闭&quot;的场景有哪些呢？下面给列举一下：</p><table><thead><tr><th>场景</th><th>具体描述</th></tr></thead><tbody><tr><td>从当前activity启动新activity后</td><td>当前activity会调用onSaveInstanceState()</td></tr><tr><td>屏幕切换，横屏切竖屏及竖屏切横屏</td><td>切换时，系统会先销毁activity，切换后系统再创建新的activity，</td></tr><tr><td>所以会调用onSaveInstanceState()</td><td></td></tr><tr><td>按HOME键后</td><td>按下home键，会启动新的应用，当前activity会调用onSaveInstanceState()</td></tr><tr><td>关闭屏幕显示</td><td>进入熄屏界面，当前activity会调用onSaveInstanceState()</td></tr><tr><td>切换白天黑夜模式</td><td>当未配置configChange时，切换白天黑夜模式，当前activity会调用onSaveInstanceState()</td></tr></tbody></table><h3 id="c-调用时机" tabindex="-1"><a class="header-anchor" href="#c-调用时机" aria-hidden="true">#</a> c.调用时机</h3><p>肯定在调用onStop()前被调用，但不保证在onPause()前 / 后，一般是在onPause()后调用。</p><h3 id="d-使用方式" tabindex="-1"><a class="header-anchor" href="#d-使用方式" aria-hidden="true">#</a> d.使用方式</h3><p>当需要保持状态时，在onSaveInstanceState()内执行以下逻辑：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onSaveInstanceState</span><span class="token punctuation">(</span><span class="token class-name">Bundle</span> outState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//调用父类方法帮助UI存储状态</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onSaveInstanceState</span><span class="token punctuation">(</span>outState<span class="token punctuation">)</span><span class="token punctuation">;</span>
    outState<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span><span class="token class-name">ActionUtils</span><span class="token punctuation">.</span><span class="token constant">SRCDISPLAY</span><span class="token punctuation">,</span> mSrcDisplay<span class="token punctuation">)</span><span class="token punctuation">;</span>
    outState<span class="token punctuation">.</span><span class="token function">putInt</span><span class="token punctuation">(</span><span class="token string">&quot;Control_State&quot;</span><span class="token punctuation">,</span> mControlState<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当需要恢复时，在onCreate()内部执行以下逻辑：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token class-name">Bundle</span> savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//首次启动时，获取Intent内部传入的bundle</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>savedInstanceState <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Intent</span> intent <span class="token operator">=</span> <span class="token function">getIntent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Bundle</span> bundle <span class="token operator">=</span> intent<span class="token punctuation">.</span><span class="token function">getExtras</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mSrcDisplay <span class="token operator">=</span> bundle<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token class-name">ActionUtils</span><span class="token punctuation">.</span><span class="token constant">SRCDISPLAY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//savedInstanceState不为空，说明执行了onSaveInstanceState()，直接获取对应的状态</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        mSrcDisplay <span class="token operator">=</span> savedInstanceState<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token class-name">ActionUtils</span><span class="token punctuation">.</span><span class="token constant">SRCDISPLAY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mControlState <span class="token operator">=</span> savedInstanceState<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">&quot;Control_State&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>布局每个View默认实现：onSaveInstanceState()，即UI的任何改变都会自动的存储和在activity重新创建的时候自动的恢复(只有在为该UI提供了唯一ID后才起作用)； 若需复写该方法从而存储额外的状态信息时，应先调用父类的onSaveInstanceState()（因为默认的onSaveInstanceState()帮助UI存储它的状态）； 只使用该方法记录Activity的瞬间状态（UI的状态），而不是去存储持久化数据，因为onSaveInstanceState()调用时机不确定性；可使用 onPause()[一定会执行]存储持久化数据；</p><h2 id="四-activity状态恢复" tabindex="-1"><a class="header-anchor" href="#四-activity状态恢复" aria-hidden="true">#</a> 四.Activity状态恢复</h2><h3 id="a-调用入口-1" tabindex="-1"><a class="header-anchor" href="#a-调用入口-1" aria-hidden="true">#</a> a.调用入口</h3><p>Activity提供了onRestoreInstanceState()方法，该方法是Activity在重新创建后恢复之前保存状态的核心方法。</p><h3 id="b-调用场景-1" tabindex="-1"><a class="header-anchor" href="#b-调用场景-1" aria-hidden="true">#</a> b.调用场景</h3><p>若被动关闭了Activity，即调用了onSaveInstanceState()，那么下次启动时会调用onRestoreInstanceState()。</p><h3 id="c-调用时机-1" tabindex="-1"><a class="header-anchor" href="#c-调用时机-1" aria-hidden="true">#</a> c.调用时机</h3><p>onCreate()---&gt;onStart()---&gt;onRestoreInstanceState()---&gt;onResume()</p><h3 id="d-使用方式-1" tabindex="-1"><a class="header-anchor" href="#d-使用方式-1" aria-hidden="true">#</a> d.使用方式</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onRestoreInstanceState</span><span class="token punctuation">(</span><span class="token class-name">Bundle</span> savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onRestoreInstanceState</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mSrcDisplay <span class="token operator">=</span> savedInstanceState<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token class-name">ActionUtils</span><span class="token punctuation">.</span><span class="token constant">SRCDISPLAY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mControlState <span class="token operator">=</span> savedInstanceState<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">&quot;Control_State&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token operator">*</span><span class="token operator">*</span>注意：<span class="token operator">*</span><span class="token operator">*</span>onSaveInstanceState（）、onRestoreInstanceState（）不一定 成对被调用
   如：当正在显示<span class="token class-name">Activity</span> <span class="token class-name">A</span>时，用户按下<span class="token constant">HOME</span>键回到主界面，然后用户紧接着又返回到<span class="token class-name">Activity</span> <span class="token class-name">A</span>，此时<span class="token class-name">Activity</span> <span class="token class-name">A</span>一般不会因为内存的原因被系统销毁，故<span class="token class-name">Activity</span> <span class="token class-name">A</span>的<span class="token function">onRestoreInstanceState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>不会被执行；
   针对以上情况，onSaveInstanceState保持的参数可以选择在<span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>内部进行解析使用，因为onSaveInstanceState的bundle参数会传递到onCreate方法中，可选择在<span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>中做数据还原。
   <span class="token operator">*</span><span class="token operator">*</span>至此：<span class="token class-name">Activity</span>的启动模式及<span class="token class-name">Activity</span>的状态保持及恢复介绍完毕。<span class="token operator">*</span><span class="token operator">*</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,55),b={href:"https://www.jianshu.com/p/f7f66a5d1525",target:"_blank",rel:"noopener noreferrer"};function S(A,f){const t=i("ExternalLinkIcon");return c(),o("div",null,[l,n("p",null,[a("Activity是"),n("a",d,[a("Android组件"),s(t)]),a("中最基本也是最为常见用的四大组件（Activity，Service服务，Content Provider内容提供者，BroadcastReceiver广播接收器）之一 .")]),n("p",null,[a("Activity是一个应用程序"),n("a",u,[a("组件"),s(t)]),a("，提供一个"),n("a",v,[a("屏幕"),s(t)]),a("，用户可以用来交互为了完成某项任务。")]),k,h,n("p",null,[a("关于Activity启动流程请参考之前的文章"),n("a",y,[a("Android activity启动流程分析"),s(t)])]),m,n("p",null,[a("本文转自 "),n("a",b,[a("https://www.jianshu.com/p/f7f66a5d1525"),s(t)]),a("，如有侵权，请联系删除。")])])}const I=e(r,[["render",S],["__file","Activityqidongmoshiyuzhuangtaibaocunjihuifuxiangjie.html.vue"]]);export{I as default};
