import{_ as d,r as o,o as i,c as l,b as n,d as t,e as a,a as e}from"./app-ee4ba21e.js";const c={},r=e(`<h2 id="find命令基本使用" tabindex="-1"><a class="header-anchor" href="#find命令基本使用" aria-hidden="true">#</a> find命令基本使用</h2><p><strong>语法格式</strong>：find [路径] [参数] [查找和搜索范围]</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>find /etc -name &quot;*.conf“
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>常用参数</strong>：</p><table><thead><tr><th>-name</th><th>按名称查找</th></tr></thead><tbody><tr><td>-size</td><td>按大小查找</td></tr><tr><td>-user</td><td>按属性查找</td></tr><tr><td>-type</td><td>按类型查找</td></tr><tr><td>-iname</td><td>忽略大小写</td></tr></tbody></table><h2 id="grep命令基本使用" tabindex="-1"><a class="header-anchor" href="#grep命令基本使用" aria-hidden="true">#</a> grep命令基本使用</h2>`,6),p={href:"https://so.csdn.net/so/search?q=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},u=e(`<p><strong>语法格式</strong>：grep -option（参数） ‘word’（关键词） file（文本文件）；</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">grep</span> <span class="token string">&quot;quail&quot;</span> /etc/passwd <span class="token parameter variable">-n</span> <span class="token parameter variable">-s</span> <span class="token parameter variable">-r</span> <span class="token comment">#显示行号，不显示错误信息，递归查找子目录文件</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>grep常用参数：</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>-e:		使用PATTERN作为模式。这可以用于指定多个搜索模式，或保护以连字符（- ）开头的图案。指定字符串做为查找文件内容的样式

-f:		指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式
-w:		精准匹配字符串，必须完全符合，包含大小写下划线空格等
-i:		忽略大小写，可以和 <span class="token parameter variable">-w</span> 一起使用
-o:		参数只输出匹配到的字符串，不会输出匹配行中其他的信息
-r:		递归文件夹，从当前文件夹向下递归查找所有子文件夹中的文件（不包含链接文件，包含二进制文件，文本等）
-n:		匹配到具体字符串后，显示字符串在文本中的行数，或者是组合指令中显示匹配的字符串是在上一个指令输出的第几行
-R:		查找所有文件包含子目录
-s:		不显示错误信息	
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重要参数(查询排除指定文件夹，或者二进制文件)：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>--binary-file<span class="token operator">=</span>without-match：   排除二进制文件查询。

<span class="token parameter variable">--exclude</span><span class="token operator">=</span>GLOB：      		跳过基本名称与GLOB匹配的文件（使用通配符匹配）。文件名GLOB可以使用 * 和<span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>作为通配符，和<span class="token punctuation">\\</span>引用通配符或反斜杠字符。
		搜索其文件名和GLOB通配符相匹配的文件的内容来查找匹配使用方法： <span class="token function">grep</span> <span class="token parameter variable">-H</span> <span class="token parameter variable">--exclude</span><span class="token operator">=</span>c* <span class="token string">&quot;old&quot;</span> ./* c*是通配文件名的通配符./* 指定需要先通配文件名的文件的范围，必须要给*，不然就匹配不出内容，<span class="token punctuation">(</span>如果不给*,带上-r选项也可以匹配<span class="token punctuation">)</span>。
		
--exclude-dir<span class="token operator">=</span>poky：     	跳过指定的目录，指定的poky目录下的任何文件都不会去查找。匹配一个目录下的很多内容的同时，还要让一些子目录不接受匹配，就使用此选项。
--exclude-from<span class="token operator">=</span>FILE：    	跳过文件和目录匹配，跳过FILE（文件或者文件夹），但是这条指令在跳过文件夹时，没有直接使用--exclude-dir效率高。
<span class="token parameter variable">--include</span><span class="token operator">=</span>GLOB：      		仅搜索其基本名称与GLOB匹配的文件（使用--exclude下所述的通配符匹配）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>grep 正则表达式主要参数：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>\\：   忽略正则表达式中特殊字符的原有含义
^：  匹配正则表达式的开始行
$：  匹配正则表达式的结束行
\\&lt;：  从匹配正则表达 式的行开始
\\&gt;：  到匹配正则表达式的行结束
[ ]：  单个字符，如[A]即A符合要求
[ - ]：  范围，如[A-Z]，即A、B、C一直到Z都符合要求
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="linux重定向" tabindex="-1"><a class="header-anchor" href="#linux重定向" aria-hidden="true">#</a> Linux重定向</h2><p>Linux中标准的输入设备是默认指的是键盘，标准的输出设备默认指的是显示器。</p><ul><li>输入重定向：指的是重新指定设备来代替键盘作为新的输入设备。</li><li>输出重定向：指的是重新指定设备来代替显示器作为新的输出设备。</li></ul><p>通常是用文件或命令的执行结果来代替键盘作为新的输入设备，而新的输出设备通常指的就是文件。</p><h3 id="输入重定向" tabindex="-1"><a class="header-anchor" href="#输入重定向" aria-hidden="true">#</a> 输入重定向</h3><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将指定文件作为命令的输入设备</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的输入设备，该命令的执行结果输出到文件2中</td></tr></tbody></table><h3 id="输出重定向" tabindex="-1"><a class="header-anchor" href="#输出重定向" aria-hidden="true">#</a> 输出重定向</h3><p>输出重定向分为<strong>标准输出重定向</strong>和<strong>错误输出重定向</strong>两种技术。</p><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。</td></tr><tr><td>命令 2&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。</td></tr><tr><td><code>命令 &gt;&gt; 文件2&gt;&amp;1</code> 或 <code>命令 &amp;&gt;&gt; 文件</code></td><td>将标准输出或错误输出写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。注意。第一种格式中，最后的<code>2&gt;&amp;1</code>是一体的，可以认为是固定写法。</td></tr></tbody></table><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat Linux.txt &gt; demo.txt</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat demo.txt</span>
Linux
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat Linux.txt &gt; demo.txt</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat demo.txt</span>
Linux     <span class="token operator">&lt;</span>--这里的 Linux 是清空原有的 Linux 之后，写入的新的 Linux
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat Linux.txt &gt;&gt; demo.txt</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat demo.txt</span>
Linux
Linux     <span class="token operator">&lt;</span>--以追加的方式，新数据写入到原有数据之后
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat b.txt &gt; demo.txt</span>
cat: b.txt: No such <span class="token function">file</span> or directory  <span class="token operator">&lt;</span>-- 错误输出信息依然输出到了显示器中
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat b.txt 2&gt; demo.txt</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat demo.txt</span>
cat: b.txt: No such <span class="token function">file</span> or directory  <span class="token operator">&lt;</span>--清空文件，再将错误输出信息写入到该文件中
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat b.txt 2&gt;&gt; demo.txt</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat demo.txt</span>
cat: b.txt: No such <span class="token function">file</span> or directory
cat: b.txt: No such <span class="token function">file</span> or directory  <span class="token operator">&lt;</span>--追加写入错误输出信息
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="sed命令" tabindex="-1"><a class="header-anchor" href="#sed命令" aria-hidden="true">#</a> sed命令</h2><p><code>sed</code>命令采用流编辑模式，最明显的特点是，在<code>sed</code>处理数据之前，需要预先提供一组规则，<code>sed</code>会按照此规则来编辑数据。</p><p><code>sed</code>会根据脚本命令来处理文本文件中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中，此命令执行数据的顺序如下：</p><ol><li>每次仅读取一行内容；</li><li>根据提供的规则命令匹配并修改数据。注意，<code>sed</code>默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据；</li><li>将执行结果输出；</li></ol><p>将一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。</p><p><code>sed</code>命令的基本格式如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># sed [选项] [脚本命令] 文件名</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下表是<code>sed</code>命令常用选项及含义</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-e 脚本命令</td><td>该选项会将其后的脚本命令添加到已有的命令中。（多点编辑）</td></tr><tr><td>-f 脚本命令</td><td>该选项会将其后文件中的脚本命令添加到已有的命令中。</td></tr><tr><td>-n</td><td>默认情况下，<code>sed</code>命令会将STDIN的数据输出到终端上。但如果加上<code>-n</code>参数，则只有经过<code>sed</code>特殊处理的那一行才会被列出来。</td></tr><tr><td>-i</td><td>此选项会直接修改源文件，要慎用。</td></tr></tbody></table><p>脚本命令说明</p><p><code>[n1,[n2]] function</code></p><p><code>n1,n2：</code>不见得会存在，一般代表<strong>选择进行动态的行数</strong>，举例来说，如果我的动作需要在10到20行之间进行，则<code>10,20[动作行为]</code></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>新增，a的后面可以接字符串，而这些字符串会在新的一行出现（当前的下一行）</td></tr><tr><td>c</td><td>取代，c的后面可以接字符串，这些字符串可以取代n1,n2之间的行</td></tr><tr><td>d</td><td>删除</td></tr><tr><td>i</td><td>插入，i的后面可以接字符串，这些字符串在目前的上一行出现</td></tr><tr><td>s</td><td>取代，可以直接进行取代的工作，这个s的动作可以搭配正则表达式。</td></tr><tr><td>p</td><td>打印，将某个选择的数据打印出来</td></tr></tbody></table><p><strong><code>sed</code>后面接的动作，务必以“两个单引号”括住。</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sed</span> <span class="token string">&#39;s/要被取代的字符串/新的字符串/g&#39;</span>

<span class="token comment">#替换22为55</span>
<span class="token function">cat</span> <span class="token function">sed</span><span class="token operator">|</span><span class="token function">sed</span> <span class="token string">&#39;s#22#55#g&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2>`,34),v={href:"https://blog.csdn.net/qq_36553387/article/details/117715160",target:"_blank",rel:"noopener noreferrer"},m={href:"https://blog.csdn.net/m0_50668851/article/details/108473882",target:"_blank",rel:"noopener noreferrer"};function h(b,g){const s=o("ExternalLinkIcon");return i(),l("div",null,[r,n("p",null,[t("Grep称为全局"),n("a",p,[t("正则表达式"),a(s)]),t("检索工具")]),u,n("p",null,[n("strong",null,[n("a",v,[t("Linux重定向，grep，sed，awk命令"),a(s)])])]),n("p",null,[n("strong",null,[n("a",m,[t("见博客参考连接grep的使用"),a(s)])])])])}const x=d(c,[["render",h],["__file","find_grep_sedmingling.html.vue"]]);export{x as default};
