---
title: Android 预置第三方应用
date: 2023-01-03
tags:
 - android
categories: 
 - android
sticky: 
   true
---



系统开机时会进行应用的加载(或者说安装)，所以我们大体上来说就是需要把要内置的apk放到指定目录就行。最常见的应该是下面四个

1. system/app/ ：该目录下存放的是一些系统级的应用，该目录下的应用能获取到比较高的权限，应用不可卸载，如Phone、Contacts等
2. system/priv-app/ ：该目录是从Android 4.4开始出现的目录，它存放的是一些系统核心应用，能获取到比system/app/下应用更高的权限，应用不可卸载，如:Setting、SystemUI等。
3. vendor/app/ ：该目录存放制造商的一些应用，应用不可卸载。
4. data/app/：该目录下存放的一些第三方应用，应用可卸载。用户手动安装的应用就是放在这个目录下

更多的可以看具体的代码，也可以自行添加。
源码是在`frameworks\base\services\core\java\com\android\server\pm\PackageManagerService.java`实例化时通过`scanDirTracedLI`方法进行扫描安装，可通过查看串口查看相关日志`logcat -s PackageManage`r。

![image-20230103134804209](https://raw.githubusercontent.com/shug666/image/main/images/image-20230103134804209.png)

## Android 预置第三方应用

Android 8.0及以上平台预置第三方apk，踩了不少坑，这里做一下笔录。

正常情况预置apk到Data目录很简单，但是这里会遇到一个问题，  

1. 如果在不改变apk签名的情况下预置到Data目录，编译后可以看到out 目录下确实是有这个apk，但是刷机系统跑起来后会因为签名校验不过（android 7.0之后增加的APK Signature Scheme v2签名方案），导致这个apk自动被系统删除。  
2. 如果将apk的签名改为系统签名预置到data目录，编译后刷机都可以正常运行，但是一般apk都有在线升级的功能，一旦apk有新版本了会因为apk签名被改变导致升级不了

**实现方案**  

将第三方应用预置到一个目录，比如/system/pre_install、系统第一次起来时，将这个目录下的所有apk文件拷贝到data/app下或者通过pm脚本安装目录下的所有apk。

### **将第三方应用预置到系统目录**

有两种方式实现

```handlebars
1.通过编写Android.mk 将apk 文件拷贝到指定系统编译目录
2.直接将目录下的所有apk 文件拷贝到系统编译目录
```

方式1: 属于常规操作，缺点是每新增一个第三方apk文件，都需要重新修改Android.mk文件

```makefile
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE_TAGS := optional
LOCAL_MODULE := RunningMyCountry
LOCAL_SRC_FILES := RunningMyCountry.apk
LOCAL_MODULE_CLASS := APPS
LOCAL_PRIVILEGED_MODULE := true
LOCAL_MODULE_PATH := $(TARGET_OUT)/pre_install
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_CERTIFICATE := PRESIGNED

include $(BUILD_PREBUILT)
```

方式2: 这种方式简单快捷，后续新增apk 也很方便，新增一个目录preintall/prethirdapk、并将apk文件全部放置其中，然后加入编译选项

`/device.mk`

```makefile
PRODUCT_COPY_FILES += \
    $(call find-copy-subdir-files,*,device/amlogic/$(PRODUCT_DIR)/preinstall/prethirdapk/,/$(TARGET_COPY_OUT_VENDOR)/preinstall)
```

**注意**：直接拷贝apk文件，系统编译时会报错`Prebuilt apk found in PRODUCT_COPY_FILES: preinstallApk, use BUILD_PREBUILT instead!`

`vim build/make/core/Makefile +28`，屏蔽check-product-copy-files即可

```sh
@@ -28,7 +28,6 @@ product_copy_files_ignored :=
 $(foreach cf,$(unique_product_copy_files_pairs), \
     $(eval _src := $(call word-colon,1,$(cf))) \
     $(eval _dest := $(call word-colon,2,$(cf))) \
-    $(call check-product-copy-files,$(cf),$(_dest)) \
```

### **第三方应用预装到系统**

```handlebars
1.系统第一次起来时，将这个目录下的所有apk文件拷贝到data/app下，系统自动解析
2.系统第一次起来时，通过pm脚本安装目录下的所有apk
```

两种方式大同小异，略有点不同

#### **1.将目录下的apk 直接拷贝到/data/apk，Android 9.0会报错**

```java
"Application package " + pkg.packageName
                                + " not found; ignoring."

```

修改如下（解析data app时，去掉SCAN_REQUIRE_KNOWN 标记）：

```java
//第一次开机去掉SCAN_REQUIRE_KNOWN
if(isFirstBoot()){
	scanDirTracedLI(sAppInstallDir, 0, scanFlags, 0);
}else {
	scanDirTracedLI(sAppInstallDir, 0, scanFlags|SCAN_REQUIRE_KNOWN, 0);
}
```

#### **2.增加pm preinstall 命令**

******

```java
--- a/services/core/java/com/android/server/pm/PackageManagerShellCommand.java
+++ b/services/core/java/com/android/server/pm/PackageManagerShellCommand.java
@@ -26,6 +26,7 @@ import android.accounts.IAccountManager;
 import android.app.ActivityManager;
 import android.app.ActivityManagerInternal;
 import android.app.Application;
+import android.app.PackageInstallObserver;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.IIntentReceiver;
@@ -156,6 +157,8 @@ class PackageManagerShellCommand extends ShellCommand {
                     return runQueryIntentReceivers();
                 case "install":
                     return runInstall();
+                case "preinstall":
+                    return preInstall();
                 case "install-abandon":
                 case "install-destroy":
                     return runInstallAbandon();
@@ -898,11 +901,60 @@ class PackageManagerShellCommand extends ShellCommand {
         return 0;
     }

+    private int preInstall()  throws RemoteException {
+        final PrintWriter pw = getOutPrintWriter();
+        String path = getNextArg();
+        pw.println("preInstall path: " + path);
+        if (path == null) {
+            pw.println("Error: no package specified");
+            return 1;
+        }
+
+        File[] files = new File(path).listFiles();
+        for(File apkFilePath : files) {
+            final String inPath = apkFilePath.getPath();
+            SessionParams sessionParams = new SessionParams(SessionParams.MODE_FULL_INSTALL);
+            InstallParams params = new InstallParams();
+            params.sessionParams = sessionParams;
+            pw.println("preInstall pkg: " + inPath);
+            setParamsSize(params, inPath);
+            final int sessionId = doCreateSession(params.sessionParams,
+                    params.installerPackageName, params.userId);
+            boolean abandonSession = true;
+            try {
+                if (inPath == null && params.sessionParams.sizeBytes == -1) {
+                    pw.println("Error: must either specify a package size or an APK file : "+inPath);
+                    continue;
+                }
+                if (doWriteSplit(sessionId, inPath, params.sessionParams.sizeBytes, "base.apk",
+                        false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) {
+                    pw.println("doWriteSplit Error :"+inPath);
+                    continue;
+                }
+                if (doCommitSession(sessionId, false /*logSuccess*/)
+                        != PackageInstaller.STATUS_SUCCESS) {
+                    pw.println("doCommitSession Error :"+inPath);
+                    continue;
+                }
+                abandonSession = false;
+                pw.println("preInstall : " + inPath+ " Success!");
+            } finally {
+                if (abandonSession) {
+                    try {
+                        doAbandonSession(sessionId, false /*logSuccess*/);
+                    } catch (Exception ignore) {
+                    }
+                }
+            }
+        }
+        pw.println("preInstall path: " + path + " ok");
+        return 0;
+    }
```

**由于开机执行shell脚本中的pm命令无效果，也无提示信息，因此本次使用的是第一种方法。**

### 在init.rc中定义一个服务

```shell
#for install apps
#开机时系统会执行该脚本

service preinstall /system/bin/sh /system/etc/installApps.sh
    class main
    user root
    group root system
    disabled
    oneshot
    seclabel u:r:shell:s0
 
on property:persist.tv.first_boot=1
   start preinstall
```

### 准备一个脚本

```shell
#！/system/bin/sh
#在第一次开机的时候执行脚本将apk拷贝到data目录，**记得给这些apk文件赋予权限**

local install_path=/system/pre_install
local data_path=/data/app
installApp() {
  if [ ! -d $data_path/$1/ ];then
    cp -rf $install_path/$1 $data_path/
    chmod 777 $data_path/$1
    chmod 777 $data_path/$1/*
  fi
}

installApp WormWars
installApp CrazyPop
installApp GalaFight
installApp ShootBall
installApp RunningMyCountry
```

### 将脚本拷贝到system/etc目录下

在android.mk文件中定义，将脚本拷贝到板载的system/分区目录下，如product.mk中

```sh
PRODUCT_COPY_FILES += \
    $(LOCAL_PATH)/installApps.sh:system/etc/installApps.sh
```

### 在SystemServer中去启动

在SystemServer中去启动这个服务,使得系统第一次开机的时候启动这个服务，不需要重复创建**（由于init.rc服务启动时间过早，而/data分区还未挂载导致文件拷贝失败的情况）**

```java
private void startBootstrapServices() {
        Slog.i(TAG, "Reading configuration...");
		//.............
		if(SystemProperties.getBoolean("persist.tv.first_boot_flag",true)){
		   SystemProperties.set("persist.tv.first_boot","1");
		   SystemProperties.set("persist.tv.first_boot","0");
		}
    	//.............
}
```

### 取消/data/app目录的限制

`PackageManagerService.java`中判断是否是第一次预置apk

```java
//SCAN_REQUIRE_KNOWN的限制
//scanDirTracedLI(sAppInstallDir, 0, scanFlags|SCAN_REQUIRE_KNOWN, 0);
if (SystemProperties.getBoolean("persist.tv.first_boot_flag",true)){
	scanDirTracedLI(sAppInstallDir, 0, scanFlags, 0);
}else {
	scanDirTracedLI(sAppInstallDir, 0, scanFlags|SCAN_REQUIRE_KNOWN, 0);
}

//....................

final long dataScanTime = SystemClock.uptimeMillis() - systemScanTime - startTime;
final int dataPackagesCount = mPackages.size() - systemPackagesCount;
//判断应用是否全部已安装完成
if(SystemProperties.getBoolean("persist.tv.first_boot_flag",true) && dataPackagesCount >= 5){
    SystemProperties.set("persist.tv.first_boot_flag","false");
}
```

### Signature Scheme v2签名方式APK预装失败

Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。

在Android7.0以及之后的版本上预置APK时，如果APK是采用的Signature Scheme v2签名，采用原有的预置应用方式预置APK会失败，经过BUILD_PREBUILT后的apk与原apk是有差异的。Android编译系统会用zipalign对APK进行字节对齐等操作，v2 签名将验证归档中每个文件的已压缩文件内容，如有任何自定义任务篡改 APK 文件或对其进行后处理（无论以任何方式），那么v2 签名会有作废的风险

在预装apk的时候因为各个合作公司的应用签名方式都有可能不同，那么我们怎么知道要预装的第三方apk是V1还是V2签名呢？
好在google给我们提供了工具让我们验证，我们打开SDK所在目录，SDK/build-tools/27.0.1/lib 目录下有个apksigner.jar，我们可以用这个工具来验证apk是否为V2签名。
方法为：
1.将apk文件拷贝至SDK/build-tools/27.0.1/lib目录下
2.打开命令行窗口输入java -jar apksigner.jar verify -v MeiTuan.apk ,接着会出现如下信息，V2为true表示apk做了V2签名。

```shell
java -jar apksigner.jar verify -v MeiTuan.apk 
Verifies
Verified using v1 scheme (JAR signing): true
Verified using v2 scheme (APK Signature Scheme v2): true
```

**解决方案**

在预置APK build的时候不让其走编译流程，在APK的 Android.mk加入下面的Shell拷贝脚本：

```shell
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE := RunningMyCountry
$(shell mkdir -p $(TARGET_OUT)/pre_install/$(LOCAL_MODULE))
$(shell cp $(LOCAL_PATH)/$(LOCAL_MODULE).apk $(TARGET_OUT)/pre_install/$(LOCAL_MODULE)/$(LOCAL_MODULE).apk)
```

这样基本就完成了，亲测没有问题。

## 总结

编译到系统中后，将镜像重新刷到机器上，启动系统。

系统起来后，通过dmsg 查看系统消息，查看脚本是否有执行，参考https://www.codenong.com/cs79041174/

代码中进行拷贝操作可参考https://blog.csdn.net/csdn_pcb/article/details/85867426

android /data分区下的目录加密策略读取和设置，参考https://blog.csdn.net/zmlovelx/article/details/125664260?spm=1001.2014.3001.5502

ANDROID-预制APK的四种方法总结https://blog.csdn.net/longmin96/article/details/125921274

**巨坑，请注意：**

> 一定要先修改源码取消/data/app目录下的限制，
>
> 同时拷贝到/data/app目录下后要给权限否则会解析失败，导致无法安装
>
> 要在SystemServer中去启动脚本，init.rc启动服务过快

## 补充

## mk语法规则

关键的语法规则

**LOCAL_PRIVILEGED_MODULE := true**

（1）决定了其编译后的在ROM中的安装位置
 （2）如果不设置或者设置为false，安装位置为system/app；如果设置为true，安装位置为system/priv-app。

**LOCAL_CERTIFICATE := platform**

```objectivec
    （1）用于设置签名
            ① testkey：普通APK，默认情况下使用。当不设置的时候，默认使用这一项。
            ② platform：该APK完成一些系统的核心功能。经过对系统中存在的文件夹的访问测试，这种方式编译出来的APK所在进程的UID为system。
            ③ shared：该APK需要和home/contacts进程共享数据。
            ④ media：该APK是media/download系统中的一环。
            ⑤ PRESIGNED ：使用原来的签名，就是已经签过名了。
    （2）Settings.apk 就是 platform 级别的签名，系统级应用都应该使用这个签名
```

**LOCAL_DEX_PREOPT := false**

如果以后对应的APK要进行在线升级，则需要把这个加上。编译时不会进行预优化，保证了APK的完整性。

**LOCAL_PREBUILT_JNI_LIBS :=**

（1）用于加载库
 （2）参考

```shell
LOCAL_PREBUILT_JNI_LIBS := \
    lib/armeabi-v7a/libserial_port.so
```

**LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS)**

（1）预置apk到/data/app中，即让预置的apk可以卸载。
（2）在5.0 6.0之后的系统中，这样配置即可实现这个功能。安卓9.0有限制，需修改源码，见正文

像**TARGET_OUT_APPS**这些变量在build/make/core/envsetup.mk里有所定义。