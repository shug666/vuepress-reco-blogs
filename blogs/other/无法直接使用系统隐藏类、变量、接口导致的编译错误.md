---
title: Android 无法直接使用系统隐藏类、变量、接口导致的编译错误
date: 2023-04-13
tags:
 - android
categories: 
 - android
sticky: 
   true
---

## 一、AS编译不过的原因

### 具备全部API的Framework.jar

Android Studio编译都过不了，原因是虽然在系统层已经做了适配，但是Android Studio它的API还是根据google默认的API来进行编译，google怎么会知道你自己要新增什么方法。那么我们怎么办才能正常生成apk呢?  首先找到你的项目源码，

找到 `out\target\common\obj\JAVA_LIBRARIES\framework_intermediates` 目录下的classes.jar文件，这个文件就是我们要的framework.jar包

![image-20230106152648019](https://raw.githubusercontent.com/shug666/image/main/images/image-20230106152648019.png)

其中，Android 11默认编译不会生成framework的classes.jar，需要在已经完整编译后，使用下面这条命令来编译生成对应的classes.jar。命令中javac-check 是指用javac编译 java文件或模块。make javac-check-framework 意思是用 javac 编译 framework 模块。

```makefile
make javac-check-framework
```

命令执行后可生成如下路径的jar包，改名为framework.jar或其他你喜欢的名字就可以用来导入AS工程

这个jar包才是可以供AS使用的，它有自己一定的大小，我这里是19M左右，因平台而异。

> 而如果你天真的直接在out目录下搜索framework.jar也是可以搜到的，但是这些jar包都是不起作用的，我刚开始在网上搜一些资料，大部分没有点名这个问题，导致自己也走了很多的弯路，这些jar包都是几kb左右，所以大家一定要找对文件（一定是有大小的，而不是几kb），不要走这样的弯路。

## 二、替换SDK下的android.jar

备份原有的android.jar，替换新的jar

![img](https://raw.githubusercontent.com/shug666/image/main/images/2737084-20220517114518803-154205959.png)

### 1、从安卓设备拿到framework.jar包

1. 确认目标平台（手机/模拟器）
2. 下载jar（adb pull /system/framework/framework.jar）
3. 获取framework-classes.zip（jar替换为zip，获取classes.dex，dex2jar将其转为classes.jar，重命名framework-classes.zip）
4. 替换原android.jar（原android.jar站zip,解压，用3内容替换）

### 2、网上下载已经编译好的android.jar包

也可以直接是使用网上编译好的framework jar包，比如[开源项目](https://so.csdn.net/so/search?q=开源项目&spm=1001.2101.3001.7020)[aosp-android-jar](https://github.com/Reginer/aosp-android-jar)，对应找到自己需要的Android版本SDK下载导入即可。

### 3、源码生成android.jar

**采用原生的SDK的android.jar和系统隐藏接口的jar包做一个合并操作，生成自定义的android.jar来编译**

1. 找到sdk目录对应的android.jar路径，如 ”platforms\android-31“，把android.jar拷贝出来，并且解压到new_android_jar目录下
2. 在编译好的aosp源码中，找到classes-header.jar，一般路径在 “out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/class-header.jar”,同样解压到new_android_jar，覆盖同名的文件
3. 文件合并之后，需要打包，"jar cvf android.jar -C new_android_jar/ .",生成新的android.jar包
4. 生成的android.jar覆盖原来的android.jar即可

## 三、其他模块的jar

对于其他模块，对应的 jar 包生成路径是

```shell
out/target/common/obj/JAVA_LIBRARIES/xxx_intermediates/classes.jar
```

xxx 就是对应的模块的名字，如 android-support-v7-recyclerview_intermediates 。

对于 app ，对应的 jar 包生成路径是

```shell
out/target/common/obj/APP/appname_intermediates/classes.jar
```

app_name 就是 app 的名称，如 SystemUI_intermediates 。

## 四、将framework.jar添加到AS项目中

**步骤一：拷贝framework.jar到模块的libs路径下**

**步骤二：在模块中的build.gradle中使用compileOnly引入framework.jar**

```java
compileOnly files('libs/framework.jar')
```

> 如果使用的类为framework.jar中新定义的类，和SDK中原有不冲突，使用步骤一，步骤二即可，如和Android SDK中同名，会优先使用SDK中的类，framework.jar中的类不会优先使用，如果优先使用framework中的类，需要配置步骤三，步骤四。

**步骤三：在模块中的build.gradle中配置如下，在Xbootclasspath(android节点)增加framework.jar**

```java
gradle.projectsEvaluated {
    tasks.withType(JavaCompile) {
        Set<File> fileSet = options.bootstrapClasspath.getFiles();
        List<File> newFileList = new ArrayList<>()
        newFileList.add(new File("libs/framework.jar"))
        newFileList.addAll(fileSet)
        options.bootstrapClasspath = files(newFileList.toArray())
    }
}
```

或者在项目根目录的build.gradle中配置如下

```java
allprojects {
    repositories {
        google()
        jcenter()
    }
    //添加  其中app 根据你的module的名称进行替换， 后面的路径文件名都可以根据实际情况进行替换，但是开头的-Xbootclasspath/p:  这个是关键字
    gradle.projectsEvaluated {
        tasks.withType(JavaCompile) {
            options.compilerArgs.add("-Xbootclasspath/p:${rootProject.projectDir}/app/libs/framework.jar")
        }
    }
}
```

**步骤四：在模块中的build.gradle中配置如下（经测试，貌似非必需，可不添加此处代码），使得framework.jar优先于android.jar**

```java
preBuild {
    doLast {
        // 注意：iml的路径要根据自己的实际情况来写
        // def imlFile = "${rootProject.projectDir}/.idea/modules/${project.name}/${rootProject.name}.${project.name}.iml"
        def imlFile = "${rootProject.projectDir}/.idea/modules/${project.name}/${rootProject.name}.${project.name}.iml"
        try {
            def parsedXml = (new XmlParser()).parse(imlFile)
            def jdkNode = parsedXml.component[1].orderEntry.find { it.'@type' == 'jdk' }
            parsedXml.component[1].remove(jdkNode)
            def sdkString = "Android API " + android.compileSdkVersion.substring("android-".length()) + " Platform"
            new groovy.util.Node(parsedXml.component[1], 'orderEntry', ['type': 'jdk', 'jdkName': sdkString, 'jdkType': 'Android SDK'])
            groovy.xml.XmlUtil.serialize(parsedXml, new FileOutputStream(imlFile))
        } catch (FileNotFoundException e) {

        }
    }

}
```

![image-20230106151541512](https://raw.githubusercontent.com/shug666/image/main/images/image-20230106151541512.png)

**步骤五：编译运行**

  

