---
title: android 获取应用列表，清除应用数据和卸载应用
date: 2022-12-19
tags:
 - android
categories: 
 - android
sticky: 
   true
---

## 获取手机上已安装应用列表

将获取到的信息用集合返回，可以自己定义是否过滤系统应用

```java
@NonNull
    public List<String> getNotSystemApps(@NonNull Context context) {
        List<String> apps = new ArrayList<>();
        PackageManager pManager = context.getPackageManager();
        // 获取手机内所有应用
        @SuppressLint("QueryPermissionsNeeded") List<ApplicationInfo> packlist = pManager.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES );
        for (int i = 0, len = packlist.size(); i<len; i++) {
            ApplicationInfo pak = packlist.get(i);

            if (Process.SYSTEM_UID == pak.uid){
                continue;
            }
            // 判断是否是属于系统的apk
            if ((pak.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
                continue;
            }
            //第三方应用
            apps.add(pak.packageName);
        }
        return apps;
    }
```

## 根据包名，清除应用数据

```java
private void clearApplicationUserData(List<String> packages) {
        final List<String> tasks = new ArrayList<>(packages);
        IPackageDataObserver observer = new IPackageDataObserver.Stub() {
            @Override
            public void onRemoveCompleted(String packageName, boolean succeeded) throws RemoteException {
                Log.d(TAG, String.format("clear %s %b", packageName, succeeded));
                if (tasks.remove(packageName)) {
                    if (tasks.isEmpty()) {
                        uninstallApps(packages);
                    }
                }
            }
        };
        ActivityManager am = getContext().getSystemService(ActivityManager.class);
        for (String packageName : packages) {
            Log.d(TAG, "packagename :" + packageName);
            am.clearApplicationUserData(packageName, observer);
        }
    }
```

## 卸载应用

```java
private void uninstallApps(List<String> packages){
        PackageManager pkgManager = getContext().getPackageManager();
        PackageDeleteObserver observer = new PackageDeleteObserver(packages.size());
        for (String app : packages) {
            pkgManager.deletePackage(app, observer, 0);
        }
    }
```

```java
private class PackageDeleteObserver extends IPackageDeleteObserver.Stub {
        private int size;
        private int position = 0;

        public PackageDeleteObserver(int size) {
            this.size = size;
        }

        @Override
        public void packageDeleted(String arg0, int arg1)
                throws RemoteException {
            // TODO Auto-generated method stub
            position ++;
            if (position == size) {
          		//卸载完成
                Toast.makeText(getContext(),"Cleaning Successful!",Toast.LENGTH_SHORT).show();
            }
        }
    }
```

## **说明：**

**当然这两种调用方式：都是直接调用隐藏方法？正常app直接调用是无法正常调用的，还需要有以下几步操作：**

1. 清除权限：

`<uses-permission   android:name="android.permission.CLEAR_APP_USER_DATA"/>`

2. 系统应用：在清单文件下设置应用为系统应用
 `<manifest xmlns:android="http://schemas.android.com/apk/res/android"
        android:sharedUserId="android.uid.system">`

3.这一步最为重要，必须要引入framework.jar ，并且设置jar包优先于系统api编译，并配置jar包只参与编译，不参与打包。这样操作后 就避免需要利用反射去调用！！！
