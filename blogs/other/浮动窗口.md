## **1、WindowManager介绍**

　　全部Android的窗口机制是基于一个叫做WindowManager实现，这个接口可以添加view到屏幕，也可以从屏幕删除view。它面向的对象一端是屏幕，另一端就是View，直接忽视我们以前的Activity或者Dialog之类的元素。其实我们的Activity或者Diolog底层的实现也是经过WindowManager，WindowManager是全局的，整个系统只有一个WindowManager。它是显示View的最底层了。WindowManager主要用来管理窗口的一些状态、属性、view增加、删除、更新、窗口顺序、消息收集和处理等。通过`Context.getSystemService(Context.WINDOW_SERVICE)`的方式可以获得WindowManager的实例.WindowManager继承自ViewManager，里面涉及到窗口管理的三个重要方法，分别是

- addView(); 
- updateViewLayout();
- removeView();

　　在WindowManager中还有一个重要的静态类LayoutParams。通过它可以设置和获得当前窗口的一些属性。我们先来看看addView()方法，在addView中，会利用LayoutParams获得window的View属性，并为每个window创ViewRoot，ViewRoot是View和WindowManager之间的桥梁，真正把View传递给WindowManager的是通过ViewRoot的setView()方法，ViewRoot实现了View和WindowManager之间的消息传递。在将主窗口添加到WindowManger时，它首先会建立一个代理对象：

```
wm=(WindowManagerImpl)context.getSystemService(Context.WINDOW_SERVICE)
```

并且打开会话(IWindowSession),之后Window将通过该会话与WindowManager建立联系。

## **2、使用WindowManager实现浮动窗口**

```java
//Edited by mythou//http://www.cnblogs.com/mythou/　　private void createFloatView()
    {
                Button btn_floatView = new Button()
        btn_floatView = new Button(getApplicationContext());
        btn_floatView.setText("悬浮窗");

        wm = (WindowManager) getApplicationContext().getSystemService(
                Context.WINDOW_SERVICE);
        params = new WindowManager.LayoutParams();

        // 设置window type
        params.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;
        /*
         * 如果设置为params.type = WindowManager.LayoutParams.TYPE_PHONE; 那么优先级会降低一些,
         * 即拉下通知栏不可见
         */

        params.format = PixelFormat.RGBA_8888; // 设置图片格式，效果为背景透明

        // 设置Window flag
        params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
        /*
         * 下面的flags属性的效果形同“锁定”。 悬浮窗不可触摸，不接受任何事件,同时不影响后面的事件响应。
         * wmParams.flags=LayoutParams.FLAG_NOT_TOUCH_MODAL |
         * LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_NOT_TOUCHABLE;
         */

        // 设置悬浮窗的长得宽
        params.width = 100;
        params.height = 100;

        // 设置悬浮窗的Touch监听
        btn_floatView.setOnTouchListener(new OnTouchListener()
        {
            int lastX, lastY;
            int paramX, paramY;

            public boolean onTouch(View v, MotionEvent event)
            {
                switch (event.getAction())
                {
                case MotionEvent.ACTION_DOWN:
                    lastX = (int) event.getRawX();
                    lastY = (int) event.getRawY();
                    paramX = params.x;
                    paramY = params.y;
                    break;
                case MotionEvent.ACTION_MOVE:
                    int dx = (int) event.getRawX() - lastX;
                    int dy = (int) event.getRawY() - lastY;
                    params.x = paramX + dx;
                    params.y = paramY + dy;
                    // 更新悬浮窗位置
                    wm.updateViewLayout(btn_floatView, params);
                    break;
                }
                return true;
            }
        });

        wm.addView(btn_floatView, params);
        isAdded = true;
    }
```

​		上面是一段创建一个浮动窗口的代码，主要就是使用了WindowManager的addView方法，把我们创建的一个View添加到WindowManager里面去。除了使用上面的代码动态创建一个View，我们也可以直接加载某个XML文件，然后生成一个View，我们平常使用的XML布局文件解析完，都是能生成一个View对象，因此我们可以直接编写一个布局文件然后使用LayoutInflater来加载对应的View。例如下面的代码：

```java
LayoutInflater inflater = LayoutInflater.from(getApplicationContext());//加载需要的XML布局文件
RelativeLayout mInView = (RelativeLayout)inflater.inflate(R.layout.in_vedio, null, false);
wm.addView(btn_floatView, params);
```

​		如果需要实现一个全屏置顶的窗口，只要编写一个全屏的XML配置文件即可，跟我们在Activity里面使用的XML配置界面一样。 

## **3、注意事项**

　　在使用WindowManager的时候有一点需要注意的是，你只能把父节点的View添加到WindowManager里面，也就是说，你要添加的View不能是已经有父节点的某个子节点。

**[一个浮动窗口的Demo](https://files.cnblogs.com/mythou/Floating_windowActivity2013-8-7.rar)**