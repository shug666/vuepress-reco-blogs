---
title: Android Soong build编译系统
date: 2024-08-21
tags:
 - android
categories: 
 - android
sticky: 
   true
---

## **1.构建编译环境** 

### 1.1.执行envsetup.sh 

```shell
$ source build/envsetup.sh
```

用source来执行envsetup.sh，使这个脚本中的定义变量和函数在这个文件执行完后一直在当前的shell环境中都是有效的。envsetup.sh是用来加载函数和变量的，有很多变量定义是放在函数里面，所以还没有生效。

envsetup.sh中主要定义了以下环境变量：

**表1：环境变量**

| 变量                    | 说明                           |
| ----------------------- | ------------------------------ |
| ANDROID_JAVA_TOOLCHAIN  | JAVA的安装目录                 |
| ANDROID_BUILD_PATHS     | Android的build目录             |
| ANDROID_PRE_BUILD_PATHS | Prebuilt目录                   |
| ANDROID_TOOLCHAIN       | Android的编译工具目录          |
| ANDROID_PRODUCT_OUT     | 编译的产品目录                 |
| ANDROID_HOST_OUT        | 编译出来的运行的本机的文件目录 |

 **表2：envsetup.sh中定义的函数**  

| 变量            | 说明                              |
| --------------- | --------------------------------- |
| lunch           | 选择编译板型                      |
| croot           | 切换到源码树的根目录              |
| godir           | 转到包含某个文件的目录路径        |
| m               | 在源码树的根目录执行 make         |
| mm              | build 当前目录下的模块            |
| mmm             | build 指定目录下的模块            |
| mma             | 编译当前目录和它的依赖模块        |
| mmma            | 编译指定目录和它的依赖模块        |
| cgrep           | 在所有 C/C++ 文件上执行 grep      |
| ggrep           | 在所有 gradle 文件上执行 grep     |
| jgrep           | 在所有 java文件上执行 grep        |
| resgrep         | 在所有 res/*.xml 文件上执行 grep  |
| mgrep           | 在所有 makefile 文件上执行 grep   |
| sepgrep         | 在所有 sepolicy文件上执行 grep    |
| sgrep           | 在所有 源码文件上执行 grep        |
| printconfig     | 显示当前 Build 的配置信息         |
| add_lunch_combo | 在 lunch 函数的菜单中添加一个条目 |

  **增加产品配置**

envsetup.sh里加了一些产品配置。其它的大部分是在device目录下通过vendorsetup.sh来加的。 

```shell
# Execute the contents of any vendorsetup.sh files we can find.
for f in `test -d device && find -L device -maxdepth 4 -name 'vendorsetup.sh' 2> /dev/null | sort` \
         `test -d vendor && find -L vendor -maxdepth 4 -name 'vendorsetup.sh' 2> /dev/null | sort` \
         `test -d product && find -L product -maxdepth 4 -name 'vendorsetup.sh' 2> /dev/null | sort`
do
    echo "including $f"
    . $f
done
```

这段代码会搜索所有位于：device，vendor，product目录下的vendorsetup.sh文件并执行. 

这段代码会搜索所有位于：device，vendor，product目录下的vendorsetup.sh文件并执行. 

### 1.2.通常来说这个文件位于具体的项目配置目录下，

**例如：device/google/dragon lunch**  

lunch是执行envsetup.sh里的lunch函数。

执行lunch命令会列出项目中配置好的编译菜单。

通过执行add_lunch_combo函数来增加产品配置菜单

lunch最后会调用三个函数：

```shell
set_stuff_for_environment printconfig  destroy_build_var_cache
```

函数set_stuff_for_environment主要就是设置PROMPT_COMMAND，ANDROID_BUILD_PATHS，JAVA_HOME和BUILD_ENV_SEQUENCE_NUMBER等等环境变量；

 函数printconfig用来打印最终准备好的环境变量，通常如下：

```shell
PLATFORM_VERSION_CODENAME=REL  
PLATFORM_VERSION=7.0  
TARGET_PRODUCT=s900_RY_VR  
TARGET_BUILD_VARIANT=userdebug  
TARGET_BUILD_TYPE=release  
TARGET_BUILD_APPS=  
TARGET_ARCH=arm  
TARGET_ARCH_VARIANT=armv7-a-neon  
TARGET_CPU_VARIANT=cortex-a53  
TARGET_2ND_ARCH=  
TARGET_2ND_ARCH_VARIANT=  
TARGET_2ND_CPU_VARIANT=  
HOST_ARCH=x86_64  
HOST_2ND_ARCH=x86  
HOST_OS=linux  
HOST_OS_EXTRA=Linux-3.2.0-29-generic-x86_64-with-Ubuntu-12.04-precise  
HOST_CROSS_OS=windows  
HOST_CROSS_ARCH=x86  
HOST_CROSS_2ND_ARCH=x86_64  
HOST_BUILD_TYPE=release  
BUILD_ID=NRD90M  
OUT_DIR=out
```

函数destroy\_build\_var\_cache用来清除不再需要的中间环节产生的变量的值。   

**2.make流程分析**  
----------------

### **2.1. 编译入口**  

当我们在Android源码根目录下执行make的时候，会查找当前目录下的Makefile文件或者makefile文件并且执行，在android/Makefile文件中，它只有一行有用的内容：       

```makefile
### DO NOT EDIT THIS FILE ### 
include build/core/main.mk 

### DO NOT EDIT THIS FILE ###
```

因此，执行make时真正的入口是android/build/core/main.mk文件。

### **2.2. soong build系统**  

#### **2.2.1.编译系统变化**          

     随着android工程越来越大，包含的module越来越多，以makefile组织的项目编译花费的时间越来越多。谷歌在7.0开始引入了ninja进行编译系统的组织。相对于make来说ninja在大的项目管理中速度和并行方面有突出的优势，因此谷歌采用了ninja来取代之前使用的make。但是现有的android项目还是由makefile组织，因此谷歌引入了kati将makefile翻译成ninja文件。

      从Android 7.0开始，android的编译系统发生了变化，之前依赖Makefile组织编译系统，从7.0开始逐步引入了kati soong(optional未正式使用，需要USE\_SOONG=true开启)，将Android.mk文件转化成ninja文件，使用ninja文件对编译系统进行管理。   

从8.0开始，android 引入了Android.bp文件来替代之前的Android.mk文件，不同于Android.mk，Android.bp只是纯粹的配置文件，不包括分支、循环等流程控制。在android项目上如何进行选择编译、解析配置、转换成ninja等，Soong就被创造出来，将Android.bp转换为ninja文件进行管理。

同时，Soong还会编译长生一个androidmk命令可以手动将Android.mk转换成Android.bp文件。

现在的代码里，Android.bp和Android.mk是共存的，不过Android.mk会被转换成ninja文件去编译。  

#### **2.2.2. Ninja，Kati，Blueprint，Soong**   

Ninja是一个致力于速度的小型编译系统（类似于Make）；   

如果把其他编译系统比做高级语言的话，Ninja就是汇编语言。ninja核心是由C/C++编写的，同时有一部分辅助功能由python和shell实现。      

**主要有两个特点：**

1、可以通过其他高级的编译系统生成其输入文件；

2、它的设计就是为了更快的编译；      

Kati的位置是在build/kati/中，平台也自带编译好的ckati。Kati用来将makefile转换成ninja文件。      

Blueprint是生成、解析Android.bp的工具，是Soong的一部分。Soong则是专为Android编译而设计的工具，Blueprint只是解析文件的形式，而Soong则解释内容的含义。

Soong的位置在build/soong,它和build/blueprint同时期作用，他们之间的系统关系如下：

![](https://raw.githubusercontent.com/shug666/image/main/images640)

Blueprint更像是一个库，专门来翻译blueprint文件，关于Blueprint文件格式可以参考build/blueprint/Blueprints文件，soong是在blueprint上面的扩展，基于blueprint的语法定制产生Android.bp语法，解析Android.bp文件生成ninja文件。

Blueprint和Soong都是有Go语言写的项目，从7.0开始在prebuilts/go/目录下新增了go语言的运行环境，在编译是使用。

#### **2.2.3.Android ninja组织**         

注意：build-aosp\_arm.ninja在具体的项目中会被命名为：build-.ninja，而combined-aosp\_arm.ninja也会是：combined-..ninja。      

在编译过程中，将所有的android.bp文件搜集成out\\soong\\build.ninja.d , 并以此为基础生成out\\soong\\build.ninja规则。    

由所有的Android.mk生成build-aosp\_arm.ninja文件。通过combined-aosp\_arm.ninja将两个文件组织起来。      

```makefile
builddir = out

include out/build-aosp_arm.ninja

include out/soong/build.ninja

build out/combined-aosp_arm.ninja: phony out/soong/build.ninja
```

通过编译的LOG，首先搜集所有的bp文件生成build.ninja，然后搜集所有的mk文件生成build-aosp-arm.ninja文件。

```makefile
out/soong/.bootstrap/bin/soong_build out/soong/build.ninja

out/build-aosp_arm-cleanspec.ninja is missing, regenerating...

out/build-aosp_arm.ninja is missing, regenerating...

[1/894] including out/soong/Android-aosp_arm.mk ...
```

经过试验表明，soong处理后的bp文件生成build.ninja的同时还包含out/soong/Android-aosp\_arm.mk，这个文件是编译完成后模块的安装脚本，负责将模块安装到对应位置。比如我们现在处理的vndk相关vendor处理就是在这个目录下进行的。      

在out/soong目录下有两个文件.minibootstrap/build.ninja 和.bootstrap/build.ninja两个目录。.minibootstrap/build.ninja 主要是用来编译blueprint和生成.bootstrap/build.ninja。而.bootstrap/build.ninja主要是生成 soong相关工具和out/soong/build.ninja文件。

  

![](https://raw.githubusercontent.com/shug666/image/main/images640)

#### **2.2.4.make 流程**            

当我们在lunch之后执行make命令时，执行的是envsetup.sh里make函数。

```makefile
function make()
{
    _wrap_build $(get_make_command) "$@"
}

function _wrap_build()
{
    local start_time=$(date +"%s")
    "$@"
    local ret=$?
    local end_time=$(date +"%s")
    local tdiff=$(($end_time-$start_time))
    local hours=$(($tdiff / 3600 ))
    local mins=$((($tdiff % 3600) / 60))
    local secs=$(($tdiff % 60))
    local ncolors=$(tput colors 2>/dev/null)
    if [ -n "$ncolors" ] && [ $ncolors -ge 8 ]; then
        color_failed=$'\E'"[0;31m"
        color_success=$'\E'"[0;32m"
        color_reset=$'\E'"[00m"
    else
        color_failed=""
        color_success=""
        color_reset=""
    fi
    echo
    if [ $ret -eq 0 ] ; then
        echo -n "${color_success}#### build completed successfully "
    else
        echo -n "${color_failed}#### failed to build some targets "
    fi
    if [ $hours -gt 0 ] ; then
        printf "(%02g:%02g:%02g (hh:mm:ss))" $hours $mins $secs
    elif [ $mins -gt 0 ] ; then
        printf "(%02g:%02g (mm:ss))" $mins $secs
    elif [ $secs -gt 0 ] ; then
        printf "(%s seconds)" $secs
    fi
    echo " ####${color_reset}"
    echo
    return $ret
}
```

make()函数用\_wrap\_build $(get\_make\_command) "$@"调用make工具来编译代码，并用其它的一些语句记录编译的时间。

```makefile
function get_make_command()
{
    # If we're in the top of an Android tree, use soong_ui.bash instead of make
    if [ -f build/soong/soong_ui.bash ]; then
        echo build/soong/soong_ui.bash --make-mode
    else
        echo command make
    fi
}
```

函数get\_make\_command将会调用soong\_ui.bash来执行编译任务。

soong\_ui.bash里执行microfactory.bash脚本，编译出可执行的microfactory\_linux文件

```shell
source ${TOP}/build/soong/cmd/microfactory/microfactory.bash
```

使用microfactory\_linux工具编译soong\_ui

```shell
build_go soong_ui android/soong/cmd/soong_ui
```

microfactory.go里的Compile，Link也是封装了golang的编译命令。

使用soong\_ui来处理后面的编译工作

```shell
cd ${TOP}``exec "$(getoutdir)/soong_ui" "$@"
```

#### **2.2.5. mm流程**        

当我们单独编译某个模块时，在这个模块目录下输入mm命令进行编译，在build/envsetup.sh看一下具体实现过程：

```makefile
function mm()

{

local T=$(gettop)

local DRV=$(getdriver $T)

# If we're sitting in the root of the build tree, just do a

# normal build.

if [ -f build/soong/soong_ui.bash ]; then

_wrap_build $DRV $T/build/soong/soong_ui.bash --make-mode $@

else

ONE_SHOT_MAKEFILE=$M _wrap_build $DRV $T/build/soong/soong_ui.bash --make-mode $MODULES $ARGS
```

流程上同make差不多只不过目标，是单独模块组成。

同时在mm一个单独模块是，生成独立的ninja文件

```shell
combined--aosp_arm-frameworks_native_libs_gui_Android.mk.ninja 和

build- aosp_arm-frameworks_native_libs_gui_Android.mk.ninja
```

#### **2.2.6.Soong流程**      

在介绍soong编译流程之前，先介绍几个命令以便我们后续编译流程的理解，在out/soong/host/linux-x86/bin目录下，有几个命令是soong用到的，

soong\_ui: soong编译的入口   

androidmk: 后面的Android.bp用到，Android.mk一键转换为android.bp

在out/soong/.bootstrap/bin目录下有几个

out/soong/.bootstrap/bin$ ls

bpglob gotestmain gotestrunner loadplugins minibp soong\_build soong\_env          

minibp：在bootstrap是用到

soong\_build ：这个很重要，主要是将bp文件转换为ninja文件       

通过上文的分析，当我们make命令敲下去的时候，主要是执行 

```shell
prebuilts/build-tools/$(host_prebuilts)/bin/makeparallel --ninja build/soong/soong_ui.bash --make-mode $(MAKECMDGOALS)       
```

**soong\_ui.bash脚本主要是执行如下：**

```shell
func main() {

log := logger.New(os.Stderr)

defer log.Cleanup()

if len(os.Args) < 2 || !inList("--make-mode", os.Args) {

log.Fatalln("The `soong` native UI is not yet available.")

}
build.Build(buildCtx, config, build.BuildAll)    
```

主要执行soong/ui/build/build.go，从build.go就可以看到执行soong的大体流程

    ![](https://raw.githubusercontent.com/shug666/image/main/images640)

#### **2.2.7.ninja使用**  

  我们可以使用ninja 和生成的combined-aosp\_arm.ninja 编译工程或者某一个module.

```shell
$ ./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-aosp_arm.ninja
```

同在工程中make一个效果  

编译systemimage或者bootimage

```shell
$ ./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-aosp_arm.ninja  systemimage 
```

上面这样做的目的是，不用重新生成ninja文件，直接进行编译，节省部分时间。这是在没有修改Makefile的前提下

#### **2.3. 整体依赖**    

在引入了Soong和Ninjia以后，一部分模块的编译用Android.bp来进行，一部分还是用Android.mk来编译。两种编译文件最后都会转换成ninjia文件来进行最终的编译。所以编译的整体依赖还是和以前一样。

我们在Android源码根目录下执行make命令的时候，并没有传入目标，那么就会执行默认的目标。那默认的目标是什么呢？在android/build/core/main.mk中有这样几行：

```shell
 `# This is the default target.  It must be the first declared target.` `.PHONY: droid` `DEFAULT_GOAL := droid` `$(DEFAULT_GOAL): droid_targets`
```

从注释可以看出，默认编译的就是droid这个伪目标，make工具遇到伪目标以后，会检查解析伪目标的依赖，如果伪目标存在依赖，就会检查这些依赖，如果这些依赖是伪目标，就继续检查这个伪目标的依赖，如果不是伪目标，就会生成这个目标，如此一层一层递归下去。

droid是makefile里的第一个target，make命令后面没有参数的话，它就是默认的编译目标。

另外，在android/build/core/main.mk中还有这样几行：

```shell
 `# Building a full system-- the default is to build droidcore`` droid_targets: droidcore dist_files`
```

这就说明droid这个伪目标依赖droidcore和dist\_files两大部分（整体编译时TARGET\_BUILD\_APPS为空），然后再将这两个依赖逐步解析下去，可以得到编译droid的整体依赖关系如下图：    

注：可以用make showcommands来把编译过程详细的列出来。在出现编译问题时比较有用。    

![](https://raw.githubusercontent.com/shug666/image/main/images640)

**有必要说明两点：**       

1）有些依赖（比如INSTALLED\_BOOTIMAGE\_TARGET）在android/build/core/main.mk中没有定义，而是在android/build/core/Makefile中定义的；

2）上面dist\_files也是个伪目标，并且它没有任何依赖，利用dist-for-goals方法来拷贝库文件，可忽略。

  

本文转自 [https://mp.weixin.qq.com/s/C3IfATT6f6vwK1hrr35tFg](https://mp.weixin.qq.com/s/C3IfATT6f6vwK1hrr35tFg)，如有侵权，请联系删除。